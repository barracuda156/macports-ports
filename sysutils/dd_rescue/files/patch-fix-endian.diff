--- /dev/null	2023-08-24 17:23:59.000000000 +0800
+++ dd_endian.h	2023-08-24 17:56:17.000000000 +0800
@@ -0,0 +1,21 @@
+#ifndef _DD_ENDIAN_H
+#define _DD_ENDIAN_H
+
+#ifdef HAVE_ENDIAN_H
+#include <endian.h>
+#else
+
+#if ((defined(BYTE_ORDER) && (BYTE_ORDER == BIG_ENDIAN)) || \
+    (defined(__BYTE_ORDER) && (__BYTE_ORDER == __BIG_ENDIAN)) || \
+    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)))
+    #define DD_BIG_ENDIAN
+#else
+    #define DD_LITTLE_ENDIAN
+#endif
+
+#if !defined(BYTE_ORDER) && !defined(__BYTE_ORDER) && !defined(__BYTE_ORDER__)
+    #error BYTE_ORDER, __BYTE_ORDER or __BYTE_ORDER__ has to be defined
+#endif
+
+#endif
+#endif

--- ffs.h.orig	2023-02-24 05:51:27.000000000 +0800
+++ ffs.h	2023-08-24 17:58:04.000000000 +0800
@@ -24,10 +24,12 @@
 #endif
 /* __BYTE_ORDER */
 #include <sys/types.h>
-#ifdef HAVE_ENDIAN_H
-#include <endian.h>
-#endif
 
+#include "dd_endian.h"
+
+#ifdef __APPLE__
+#include <stdint.h> /* __WORDSIZE */
+#endif
 
 #ifdef HAVE_FFS
 # define myffs(x) ffs(x)
@@ -54,9 +56,6 @@
 # define myffsl(x) myffsl_c(x)
 #endif
 
-#ifndef __BYTE_ORDER
-# error Need to define __BYTE_ORDER
-#endif
 #ifndef __WORDSIZE
 # error Need to define __WORDSIZE
 #endif
@@ -93,7 +92,7 @@
 }
 #endif
 
-#if __BYTE_ORDER == __BIG_ENDIAN || defined(TEST)
+#if defined(DD_BIG_ENDIAN) || defined(TEST)
 /** Find last (highest) bit set in word val, returns a val b/w __WORDSIZE and 1, 0 if no bit is set */
 static int myflsl(unsigned long val)
 {

--- md5.c.orig	2022-07-26 00:24:55.000000000 +0800
+++ md5.c	2023-08-24 17:50:01.000000000 +0800
@@ -12,10 +12,11 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
-#include <endian.h>
 #include <assert.h>
 #include <netinet/in.h>
 
+#include "dd_endian.h"
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -46,7 +47,7 @@
 // leftrotate function definition
 #define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#if defined(DD_LITTLE_ENDIAN)
 static inline void to_bytes(uint32_t val, uint8_t *bytes)
 {
 	*(uint32_t *)bytes = val;
@@ -63,7 +64,7 @@
 
 #endif
 
-#if !defined(HAVE_UNALIGNED_HANDLING) || __BYTE_ORDER != __LITTLE_ENDIAN
+#if !defined(HAVE_UNALIGNED_HANDLING) || !defined(DD_LITTLE_ENDIAN)
 /* Read val from little-endian array */
 static inline uint32_t to_int32(const uint8_t *bytes)
 {
@@ -84,12 +85,12 @@
 void md5_64(const uint8_t *ptr, hash_t *ctx)
 {
 	uint32_t _a, _b, _c, _d;
-#if !defined(HAVE_UNALIGNED_HANDLING) || __BYTE_ORDER != __LITTLE_ENDIAN
+#if !defined(HAVE_UNALIGNED_HANDLING) || !defined(DD_LITTLE_ENDIAN)
 	uint32_t ww[16];
 #endif
 	unsigned int i;
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#if defined(DD_LITTLE_ENDIAN)
 	uint32_t *w = (uint32_t *)ptr;
 	// Avoid misaligned 32bit reads (ARMv7)
 #if !defined(HAVE_UNALIGNED_HANDLING)
@@ -202,7 +203,7 @@
 	int i;
 	for (i = 0; i < 4; ++i) 
 		//*((uint32_t*)buf+i) = htonl(BSWAP32(ctx->md5_h[i]));
-#if __BYTE_ORDER == __BIG_ENDIAN
+#if defined(DD_BIG_ENDIAN)
 		*((uint32_t*)buf+i) = BSWAP32(ctx->md5_h[i]);
 #else
 		*((uint32_t*)buf+i) = ctx->md5_h[i];

--- find_nonzero.h.orig	2021-04-14 16:23:02.000000000 +0800
+++ find_nonzero.h	2023-08-24 18:19:00.000000000 +0800
@@ -13,6 +13,8 @@
 #include "ffs.h"
 #include "archdep.h"
 
+#include "dd_endian.h"
+
 extern char cap_str[64];
 extern char FNZ_OPT[64];
 
@@ -62,7 +64,7 @@
 	const unsigned long* const bptr = ptr;
 	for (; (size_t)(ptr-bptr) < ln/sizeof(*ptr); ++ptr)
 		if (*ptr)
-#if __BYTE_ORDER == __BIG_ENDIAN
+#if defined(DD_BIG_ENDIAN)
 			return sizeof(long)*(ptr-bptr) + sizeof(long)-((myflsl(*ptr)+7)>>3);
 #else
 			return sizeof(long)*(ptr-bptr) + ((myffsl(*ptr)-1)>>3);

--- pread64.h.orig	2015-04-15 16:56:38.000000000 +0800
+++ pread64.h	2023-08-24 21:02:12.000000000 +0800
@@ -10,11 +10,17 @@
 #ifndef _PREAD64_H
 #define _PREAD64_H
 
+#include "dd_endian.h"
+
+#ifdef __APPLE__
+#include <stdint.h> /* __WORDSIZE */
+#endif
+
 #ifdef HAVE_CONFIG_H
 # include "config.h"
 #endif
 
-#if !defined(HAVE_PREAD64) && __WORDSIZE == 64 && !defined(TEST_SYSCALL) && defined(HAVE_PREAD)
+#if !defined(HAVE_PREAD64) && (__WORDSIZE == 64) && !defined(TEST_SYSCALL) && defined(HAVE_PREAD)
 #define pread64 pread
 #define pwrite64 pwrite
 #define HAVE_PREAD64
@@ -25,9 +31,6 @@
 #ifdef __linux__
 # include <sys/syscall.h>
 # include <sys/types.h>
-# ifdef HAVE_ENDIAN_H
-#  include <endian.h>
-# endif
 # define __KERNEL__
 # include <asm/unistd.h>
 # ifdef __NR_pread64
@@ -35,7 +38,7 @@
 {
 #if __WORDSIZE == 64
 	return syscall(__NR_pread64, fd, buf, sz, off);
-#elif __BYTE_ORDER == __LITTLE_ENDIAN 
+#elif defined(DD_LITTLE_ENDIAN)
 #ifdef __arm__
 	return syscall(__NR_pread64, fd, buf, sz, 0, (unsigned int)off, (int)(off >> 32));
 #else
@@ -55,7 +58,7 @@
 {
 #if __WORDSIZE == 64
 	return syscall(__NR_pwrite64, fd, buf, sz, off);
-#elif __BYTE_ORDER == __LITTLE_ENDIAN
+#elif defined(DD_LITTLE_ENDIAN)
 #ifdef __arm__
 	return syscall(__NR_pwrite64, fd, buf, sz, 0, (unsigned int)off, (int)(off >> 32));
 #else
@@ -94,7 +97,7 @@
 {
 	return pread(fd, buf, sz, off);
 }
-static inline ssize_t pwrite(int fd, const void *buf, size_t sz, loff_t off)
+static inline ssize_t pwrite64(int fd, const void *buf, size_t sz, loff_t off)
 {
 	return pwrite(fd, buf, sz, off);
 }

--- sha512.c.orig	2023-02-24 05:51:27.000000000 +0800
+++ sha512.c	2023-08-24 21:24:53.000000000 +0800
@@ -19,7 +19,8 @@
 #include <netinet/in.h>
 #include <assert.h>
 #include <unistd.h>
-#include <endian.h>
+
+#include "dd_endian.h"
 
 /*
 Note 1: All variables are 64 bit unsigned integers and addition is calculated modulo 2^64 
@@ -94,7 +95,7 @@
 	       ((uint64_t)bytes[6] << 8)  |  (uint64_t)bytes[7];
 }
 #endif
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#if defined(DD_LITTLE_ENDIAN)
 static inline uint64_t htonll(const uint64_t x)
 {
 #ifdef HAVE_HTOBE64

--- libddr_crypt.c.orig	2022-07-26 18:06:31.000000000 +0800
+++ libddr_crypt.c	2023-08-24 21:37:16.000000000 +0800
@@ -44,7 +44,9 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <time.h>
-#include <endian.h>
+
+#include "dd_endian.h"
+
 #include <signal.h>
 
 #ifdef HAVE_SYS_XATTR_H
@@ -757,7 +759,7 @@
 		FPLOG(DEBUG, "Try to read xattr %s from %s file %s\n", 
 			atrnm, (state->enc? "output": "input"), name);
 	/* Longest is 128byte hex for SHA512 (8x64byte numbers -> 8x16 digits) */
-	ssize_t itln = getxattr(name, atrnm, state->sec->charbuf1, 128);
+	ssize_t itln = getxattr(name, atrnm, state->sec->charbuf1, 128, 0, 0);
 	if (itln <= 0) {
 		if (!fb)
 			FPLOG(WARN, "Could not read xattr %s of %s\n", atrnm, name);
@@ -800,7 +802,7 @@
 	//}
 	if (state->debug)
 		FPLOG(INFO, "Try to write xattr %s to output file %s\n", atrnm, name);
-	if (setxattr(name, atrnm, chartohex(state, data, dlen), 2*dlen, 0)) {
+	if (setxattr(name, atrnm, chartohex(state, data, dlen), 2*dlen, 0, 0)) {
 		if (!fb)
 			FPLOG(FATAL, "Failed writing xattr %s for %s: %s\n",
 					atrnm, name, strerror(errno));
@@ -825,7 +827,7 @@
 			 state->sxfallback, &state->saltf, &state->sset);
 	if (!r) {
 		const char* name = state->enc? state->opts->oname: state->opts->iname;
-		ssize_t itln = getxattr(name, "user.pbkdf", state->sec->charbuf1, 128);
+		ssize_t itln = getxattr(name, "user.pbkdf", state->sec->charbuf1, 128, 0, 0);
 		if (itln <= 0)
 			return r;
 		int rnd = 0;
@@ -862,7 +864,7 @@
 			sprintf(buf, "opbkdf");
 		else
 			abort();
-		if (setxattr(name, "user.pbkdf", buf, strlen(buf)+1, 0) && !state->opts->quiet)
+		if (setxattr(name, "user.pbkdf", buf, strlen(buf)+1, 0, 0) && !state->opts->quiet)
 			FPLOG(WARN, "Huh? Stored salt but could not store pbkdf to xattr\n");
 	}
 	return r;
@@ -901,7 +903,6 @@
 }
 
 
-
 #endif
 
 
--- aes_c.c.orig	2021-10-04 01:27:10.000000000 +0800
+++ aes_c.c	2023-08-24 21:51:53.000000000 +0800
@@ -32,8 +32,14 @@
 
 #include <string.h>
 #include <assert.h>
+
+#if defined(__APPLE__)
+#include <machine/endian.h>
+#else
 #include <byteswap.h>
-#include <endian.h>
+#endif
+
+#include "dd_endian.h"
 
 typedef unsigned char u8;
 typedef unsigned short u16;
@@ -438,7 +444,7 @@
 		*((u32 *)(ct)) = SWAP((st));				\
 	}
 #else	/* _MSC_VER */
-# if __BYTE_ORDER == __BIG_ENDIAN
+#if defined(DD_BIG_ENDIAN)
 #define GETU32(p) *((u32*)(p))
 #define PUTU32(ct, st) *((u32*)(ct)) = (st)
 #else	/* BIG_ENDIAN */
@@ -1036,7 +1042,7 @@
 	sha256_init(&hv);
 	rijndaelKeySetupEnc((u32*)(rkeys+16+8*rounds), crypto->userkey2, bits, rounds/2);
 	//memset(crypto->userkey2, 0, 32);
-	asm("":::"memory");
+	mem_clobber;
 }
 
 static inline
@@ -1053,7 +1059,7 @@
 	sha256_init(&hv);
 	rijndaelKeySetupDec((u32*)(rkeys+16+8*rounds), crypto->userkey2, bits, rounds/2);
 	//memset(crypto->userkey2, 0, 32);
-	asm("":::"memory");
+	mem_clobber;
 }
 
 #define DECL_KEYSETUP2(MODE, BITS)	\


--- pbkdf_ossl.c.orig	2021-04-14 16:23:02.000000000 +0800
+++ pbkdf_ossl.c	2023-08-24 21:55:18.000000000 +0800
@@ -12,8 +12,8 @@
 #include "secmem.h"
 #include <stdlib.h>
 #include <assert.h>
-#include <endian.h>
 #include <stdint.h>
+#include "dd_endian.h"
 
 #define MIN(a,b) ((a)<(b)? (a): (b))
 
--- libddr_lzo.c.orig	2022-07-26 21:53:37.000000000 +0800
+++ libddr_lzo.c	2023-08-25 07:13:05.000000000 +0800
@@ -36,9 +36,8 @@
 #include <lzo/lzo2a.h>
 #endif
 #include <time.h>
-#ifdef HAVE_ENDIAN_H
-#include <endian.h>
-#endif
+
+#include "dd_endian.h"
 
 #if __WORDSIZE == 64
 #define LL "l"
@@ -783,7 +782,7 @@
 }
 
 #undef HTONL
-#if __BYTE_ORDER == __BIG_ENDIAN
+#if defined(DD_BIG_ENDIAN)
 #define HTONL(x) x
 #else
 #define HTONL(x) (((((x) & 0xFF)) << 24) | \

--- find_nonzero.c.orig	2021-04-14 16:23:02.000000000 +0800
+++ find_nonzero.c	2023-08-25 05:40:07.000000000 +0800
@@ -12,7 +12,13 @@
 
 #include <stdio.h>
 
+#if defined(__POWERPC__)
+#define mem_clobber __asm__ volatile("or r27,r27,r27" ::: "memory")
+#elif defined(__powerpc__)
+#define mem_clobber __asm__ __volatile__ ("or 27,27,27" ::: "memory")
+#else
 #define mem_clobber	asm("":::"memory")
+#endif
 
 char cap_str[64];
 char FNZ_OPT[64];

--- secmem.h.orig	2022-12-06 20:18:57.000000000 +0800
+++ secmem.h	2023-08-24 20:25:50.000000000 +0800
@@ -65,11 +65,22 @@
 extern sec_fields *crypto;
 
 //#if defined(__i386__) || defined(__x86_64__)
-#ifdef HAVE_LFENCE
+#if defined(HAVE_LFENCE)
 #define LFENCE asm("lfence":::"memory")
+#elif defined(__POWERPC__)
+#define LFENCE __asm__ volatile ("or r27,r27,r27" ::: "memory")
+#elif defined(__powerpc__)
+#define LFENCE __asm__ __volatile__ ("or 27,27,27" ::: "memory")
 #else
 #define LFENCE asm("":::"memory")
 #endif
+
+#if defined(__POWERPC__)
+#define mem_clobber __asm__ volatile ("or r27,r27,r27" ::: "memory")
+#elif defined(__powerpc__)
+#define mem_clobber __asm__ __volatile__ ("or 27,27,27" ::: "memory")
+#else
 #define mem_clobber asm("":::"memory")
+#endif
 
 #endif
