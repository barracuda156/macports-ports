--- asmcomp/power/CSE.ml.orig	2022-03-28 20:27:36.000000000 +0800
+++ asmcomp/power/CSE.ml	2022-04-28 00:36:30.000000000 +0800
@@ -31,7 +31,7 @@
 
 method! is_cheap_operation op =
   match op with
-  | Iconst_int n -> n <= 0x7FFF_FFFFn && n >= -0x8000_0000n
+  | Iconst_int n -> n <= 32767n && n >= -32768n
   | _ -> false
 
 end



--- asmcomp/power/selection.ml.orig	2022-03-28 20:27:36.000000000 +0800
+++ asmcomp/power/selection.ml	2022-05-04 03:26:25.000000000 +0800
@@ -43,7 +43,7 @@
   | exp ->
       (Alinear exp, 0, Debuginfo.none)
 
-let is_immediate n = n <= 0x7FFF && n >= -0x8000
+let is_immediate n = (n <= 32767) && (n >= -32768)
 let is_immediate_logical n = n <= 0xFFFF && n >= 0
 
 (* Instruction selection *)
@@ -80,6 +80,8 @@
 
 method! select_operation op args dbg =
   match (op, args) with
+  (* PowerPC does not support immediate operands for multiply high *)
+    (Cmulhi, _) -> (Iintop Imulh, args)
   (* Recognize mult-add and mult-sub instructions *)
   | (Caddf, [Cop(Cmulf, [arg1; arg2], _); arg3]) ->
       (Ispecific Imultaddf, [arg1; arg2; arg3])



--- asmcomp/power/arch.ml.orig	2022-03-28 20:27:36.000000000 +0800
+++ asmcomp/power/arch.ml	2022-05-04 00:48:25.000000000 +0800
@@ -23,36 +23,39 @@
   | "ppc64" | "ppc64le" -> true
   | _ -> assert false
 
-type abi = ELF32 | ELF64v1 | ELF64v2
+type abi = PowerOpen | ELF32 | ELF64v1 | ELF64v2
 
 let abi =
   match Config.model with
-  | "ppc" -> ELF32
-  | "ppc64" -> ELF64v1
+  | "ppc" -> PowerOpen
+  | "ppc64" -> PowerOpen
   | "ppc64le" -> ELF64v2
-  | _ -> assert false
 
-type cmm_label = int
-(* Do not introduce a dependency to Cmm *)
+type cmm_label = int (* Do not introduce a dependency to Cmm *)
 
 (* Machine-specific command-line options *)
 
-let big_toc = ref true
-
-let command_line_options = [
-  "-flarge-toc", Arg.Set big_toc,
+let big_toc =
+  match Config.system with
+  | "rhapsody"  -> ref false
+  | "elf" | "bsd" | "bsd_elf" -> ref true
+
+let command_line_options =
+  match Config.system with
+  | "rhapsody"  -> []  (* Darwin does not use TOC *)
+  | "elf" | "bsd" | "bsd_elf" -> [
+   "-flarge-toc", Arg.Set big_toc,
      " Support TOC (table of contents) greater than 64 kbytes (default)";
-  "-fsmall-toc", Arg.Clear big_toc,
+   "-fsmall-toc", Arg.Clear big_toc,
      " TOC (table of contents) is limited to 64 kbytes"
-]
+   ]
 
 (* Specific operations *)
 
 type specific_operation =
-    Imultaddf                           (* multiply and add *)
-  | Imultsubf                           (* multiply and subtract *)
-  | Ialloc_far of                       (* allocation in large functions *)
-      { bytes : int; dbginfo : Debuginfo.alloc_dbginfo }
+    Imultaddf                                                        (* multiply and add *)
+  | Imultsubf                                                        (* multiply and subtract *)
+  | Ialloc_far of { bytes : int; dbginfo : Debuginfo.alloc_dbginfo } (* allocation in large functions *)
   | Ipoll_far of { return_label : cmm_label option }
 
 (* Addressing modes *)
@@ -75,7 +78,10 @@
 let size_int = size_addr
 let size_float = 8
 
-let allow_unaligned_access = true
+let allow_unaligned_access =
+  match Config.system with
+  | "rhapsody" -> false
+  | "elf" | "bsd" | "bsd_elf" -> true
 
 (* Behavior of division *)
 


--- asmcomp/power/proc.ml.orig	2022-03-28 20:27:36.000000000 +0800
+++ asmcomp/power/proc.ml	2022-05-04 03:57:01.000000000 +0800
@@ -27,33 +27,63 @@
 
 (* Registers available for register allocation *)
 
-(* Integer register map:
+(* PowerOpen:
+  Integer register map:
+    r0                  temporary, null register for some operations
+    r1                  stack pointer
+    r2                  thread pointer in 32-bit ABI
+    r3–r10              function arguments and results
+    r11                 environment pointer
+    r12                 used by dyn linker, exception handling
+    r13                 thread pointer in 64-bit ABI
+    r13–r28             general purpose, preserved by C
+    r29                 trap pointer
+    r30                 frame pointer
+    r31                 PIC-offset table
+  Floating-point register map:
+    f0                  temporary
+    f1–f13              function arguments and results
+    f14–f31             general purpose, preserved by C
+    
+    ELF:
+  Integer register map:
     0                   temporary, null register for some operations
     1                   stack pointer
     2                   pointer to table of contents
-    3 - 10              function arguments and results
-    11 - 12             temporaries
+    3–10                function arguments and results
+    11–12               temporaries
     13                  pointer to small data area
-    14 - 28             general purpose, preserved by C
+    14–28               general purpose, preserved by C
     29                  trap pointer
     30                  domain state pointer
     31                  allocation pointer
   Floating-point register map:
     0                   temporary
-    1 - 13              function arguments and results
-    14 - 31             general purpose, preserved by C
+    1–13                function arguments and results
+    14–31               general purpose, preserved by C
 *)
 
 let int_reg_name =
-  [| "3"; "4"; "5"; "6"; "7"; "8"; "9"; "10";           (* 0 - 7 *)
-     "14"; "15"; "16"; "17"; "18"; "19"; "20"; "21";    (* 8 - 15 *)
-     "22"; "23"; "24"; "25"; "26"; "27"; "28" |]        (* 16 - 22 *)
+  if Config.system = "rhapsody" then                            (* PowerOpen *)
+    [| "r3"; "r4"; "r5"; "r6"; "r7"; "r8"; "r9"; "r10";         (* 0–7 *)
+       "r14"; "r15"; "r16"; "r17"; "r18"; "r19"; "r20"; "r21";  (* 8–15 *)
+       "r22"; "r23"; "r24"; "r25"; "r26"; "r27"; "r28" |]       (* 16–22 *)
+  else
+    [| "3"; "4"; "5"; "6"; "7"; "8"; "9"; "10";                 (* 0–7 *)
+       "14"; "15"; "16"; "17"; "18"; "19"; "20"; "21";          (* 8–15 *)
+       "22"; "23"; "24"; "25"; "26"; "27"; "28" |]              (* 16–22 *)
 
 let float_reg_name =
-  [| "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8";
-     "9"; "10"; "11"; "12"; "13"; "14"; "15"; "16";
-     "17"; "18"; "19"; "20"; "21"; "22"; "23"; "24";
-     "25"; "26"; "27"; "28"; "29"; "30"; "31" |]
+  if Config.system = "rhapsody" then                            (* MacOS X *)
+    [| "f1"; "f2"; "f3"; "f4"; "f5"; "f6"; "f7"; "f8";
+       "f9"; "f10"; "f11"; "f12"; "f13"; "f14"; "f15"; "f16";
+       "f17"; "f18"; "f19"; "f20"; "f21"; "f22"; "f23"; "f24";
+       "f25"; "f26"; "f27"; "f28"; "f29"; "f30"; "f31" |]
+  else
+    [| "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8";
+       "9"; "10"; "11"; "12"; "13"; "14"; "15"; "16";
+       "17"; "18"; "19"; "20"; "21"; "22"; "23"; "24";
+       "25"; "26"; "27"; "28"; "29"; "30"; "31" |]
 
 let num_register_classes = 2
 
@@ -75,7 +105,7 @@
 
 let hard_int_reg =
   let v = Array.make 23 Reg.dummy in
-  for i = 0 to 21 do v.(i) <- Reg.at_location Int (Reg i) done; v
+  for i = 0 to 22 do v.(i) <- Reg.at_location Int (Reg i) done; v
 
 let hard_float_reg =
   let v = Array.make 31 Reg.dummy in
@@ -98,8 +128,7 @@
   if !int <= last_int then begin
     let l = phys_reg !int in
     incr int;
-    if reg_use_stack then ofs := !ofs + size_int;
-    l
+    if reg_use_stack then ofs := !ofs + size_int; l
   end else begin
     let l = stack_slot (make_stack !ofs) Int in
     ofs := !ofs + size_int; l
@@ -109,11 +138,8 @@
   if !float <= last_float then begin
     let l = phys_reg !float in
     incr float;
-    (* On 64-bit platforms, passing a float in a float register
-       reserves a normal register as well *)
-    if size_int = 8 then incr int;
-    if reg_use_stack then ofs := !ofs + size_float;
-    l
+    int := !int + (if ppc64 then 1 else 2);
+    if reg_use_stack then ofs := !ofs + size_float; l
   end else begin
     ofs := Misc.align !ofs size_float;
     let l = stack_slot (make_stack !ofs) Float in
@@ -121,9 +147,9 @@
   end
 
 let loc_int_pair last_int make_stack int ofs =
-  (* 64-bit quantities split across two registers must either be in a
-     consecutive pair of registers where the lowest numbered is an
-     even-numbered register; or in a stack slot that is 8-byte aligned. *)
+  (* 64-bit quantities split across two registers must either be
+     in a consecutive pair of registers where the lowest-numbered
+     is an even-numbered register; or in a stack slot that is 8-byte aligned. *)
   int := Misc.align !int 2;
   if !int <= last_int - 1 then begin
     let reg_lower = phys_reg !int in
@@ -138,8 +164,8 @@
     [| stack_lower; stack_upper |]
   end
 
-let calling_conventions first_int last_int first_float last_float
-      make_stack first_stack arg =
+let calling_conventions
+    first_int last_int first_float last_float make_stack first_stack arg =
   let loc = Array.make (Array.length arg) Reg.dummy in
   let int = ref first_int in
   let float = ref first_float in
@@ -169,38 +195,37 @@
     calling_conventions 0 15 100 112 outgoing (- size_domainstate_args) arg
 
 let loc_parameters arg =
-  let (loc, _ofs) =
-    calling_conventions 0 15 100 112 incoming (- size_domainstate_args) arg
-  in loc
+  let (loc, _ofs) = calling_conventions 0 15 100 112 incoming (- size_domainstate_args) arg in loc
 
 let loc_results res =
-  let (loc, _ofs) = calling_conventions 0 15 100 112 not_supported 0 res
-  in loc
+  let (loc, _ofs) = calling_conventions 0 15 100 112 not_supported 0 res in loc
 
-(* C calling conventions for ELF32:
-     use GPR 3-10 and FPR 1-8 just like ML calling conventions.
+(* C calling conventions for PowerOpen:
+     use GPR 3–10 and FPR 1–13 just like ML calling conventions,
+     but always reserve stack space for all arguments.
+     Also, using a float register automatically reserves two int registers
+     (in 32-bit mode) or one int register (in 64-bit mode).
+     (If we were to call a non-prototyped C function, each float argument
+     would have to go both in a float reg and in the matching pair of integer regs.)
+   C calling conventions for ELF32:
+     use GPR 3–10 and FPR 1–8 just like ML calling conventions.
      Using a float register does not affect the int registers.
      Always reserve 8 bytes at bottom of stack, plus whatever is needed
      to hold the overflow arguments.
    C calling conventions for ELF64v1:
-     Use GPR 3-10 for the first integer arguments.
-     Use FPR 1-13 for the first float arguments.
-     Always reserve stack space for all arguments, even when passed in
-     registers.
+     Use GPR 3–10 for the first integer arguments.
+     Use FPR 1–13 for the first float arguments.
+     Always reserve stack space for all arguments, even when passed in registers.
      Always reserve at least 8 words (64 bytes) for the arguments.
-     Always reserve 48 bytes at bottom of stack, plus whatever is needed
-     to hold the arguments.
-     The reserved 48 bytes are automatically added in emit.mlp
-     and need not appear here.
+     Always reserve 48 bytes at bottom of stack, plus whatever is needed to hold the arguments.
+     The reserved 48 bytes are automatically added in emit.mlp and need not appear here.
    C calling conventions for ELF64v2:
-     Use GPR 3-10 for the first integer arguments.
-     Use FPR 1-13 for the first float arguments.
-     If all arguments fit in registers, don't reserve stack space.
+     Use GPR 3–10 for the first integer arguments.
+     Use FPR 1–13 for the first float arguments.
+     If all arguments fit in registers, don’t reserve stack space.
      Otherwise, reserve stack space for all arguments.
-     Always reserve 32 bytes at bottom of stack, plus whatever is needed
-     to hold the arguments.
-     The reserved 32 bytes are automatically added in emit.mlp
-     and need not appear here.
+     Always reserve 32 bytes at bottom of stack, plus whatever is needed to hold the arguments.
+     The reserved 32 bytes are automatically added in emit.mlp and need not appear here.
 *)
 
 let external_calling_conventions
@@ -231,12 +256,13 @@
 
 let loc_external_arguments ty_args =
   match abi with
+  | PowerOpen ->
+      external_calling_conventions 0 7 100 112 outgoing 0 false ty_args
   | ELF32 ->
       external_calling_conventions 0 7 100 107 outgoing 8 false ty_args
   | ELF64v1 ->
       let (loc, ofs) =
-        external_calling_conventions 0 7 100 112 outgoing 0 true ty_args in
-      (loc, max ofs 64)
+        external_calling_conventions 0 7 100 112 outgoing 0 true ty_args in (loc, max ofs 64)
   | ELF64v2 ->
       let (loc, ofs) =
         external_calling_conventions 0 7 100 112 outgoing 0 true ty_args in
@@ -253,14 +279,17 @@
 (* Results are in GPR 3 and FPR 1 *)
 
 let loc_external_results res =
-  let (loc, _ofs) = calling_conventions 0 1 100 100 not_supported 0 res
-  in loc
+  let (loc, _ofs) = calling_conventions 0 1 100 100 not_supported 0 res in loc
 
 (* Exceptions are in GPR 3 *)
 
 let loc_exn_bucket = phys_reg 0
 
-(* For ELF32 see:
+(* For PowerOpen see:
+   "PowerOpen ABI"
+   https://www.sourceware.org/pub/binutils/ppc-docs/ppc-poweropen/
+
+   For ELF32 see:
    "System V Application Binary Interface PowerPC Processor Supplement"
    http://refspecs.linux-foundation.org/elf/elfspec_ppc.pdf
 
@@ -269,11 +298,11 @@
    http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html
 
    For ELF64v2 see:
-   "64-Bit ELF V2 ABI Specification -- Power Architecture"
+   "64-Bit ELF V2 ABI Specification – Power Architecture"
    http://openpowerfoundation.org/wp-content/uploads/resources/leabi/
      content/dbdoclet.50655239___RefHeading___Toc377640569.html
 
-   All of these specifications seem to agree on the numberings we need.
+   All of these specifications seem to agree on the numberings we need (what about PowerOpen?).
 *)
 
 let int_dwarf_reg_numbers =
@@ -309,8 +338,7 @@
      100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111; 112])
 
 let destroyed_at_oper = function
-    Iop(Icall_ind | Icall_imm _ | Iextcall { alloc = true; _ }) ->
-    all_phys_regs
+    Iop(Icall_ind | Icall_imm _ | Iextcall { alloc = true; _ }) -> all_phys_regs
   | Iop(Iextcall { alloc = false; _ }) -> destroyed_at_c_call
   | _ -> [||]
 
@@ -333,19 +361,19 @@
 (* See [reserved_stack_space] in emit.mlp. *)
 let reserved_stack_space_required () =
   match abi with
-  | ELF32 -> false
+  | PowerOpen | ELF32 -> false
   | ELF64v1 | ELF64v2 -> true
 
 let frame_required fd =
-  let is_elf32 =
+  let is_32 =
     match abi with
-    | ELF32 -> true
+    | PowerOpen | ELF32 -> true
     | ELF64v1 | ELF64v2 -> false
   in
   reserved_stack_space_required ()
     || fd.fun_num_stack_slots.(0) > 0
     || fd.fun_num_stack_slots.(1) > 0
-    || (fd.fun_contains_calls && is_elf32)
+    || (fd.fun_contains_calls && is_32)
 
 let prologue_required fd =
   frame_required fd



--- asmcomp/power/emit.mlp.orig	2022-03-28 20:27:36.000000000 +0800
+++ asmcomp/power/emit.mlp	2022-05-04 05:37:59.000000000 +0800
@@ -16,6 +16,9 @@
 
 (* Emission of PowerPC assembly code *)
 
+module StringSet =
+  Set.Make(struct type t = string let compare (x:t) y = compare x y end)
+
 open Cmm
 open Arch
 open Proc
@@ -29,6 +32,7 @@
 
 let reserved_stack_space =
   match abi with
+  | PowerOpen -> 32
   | ELF32 -> 0
   | ELF64v1 -> 48
   | ELF64v2 -> 32
@@ -39,11 +43,11 @@
   reserved_stack_space +
   size_int * f.fun_num_stack_slots.(0) +    (* Local int variables *)
   size_float * f.fun_num_stack_slots.(1) +  (* Local float variables *)
-  (if f.fun_contains_calls && abi = ELF32 then size_int else 0)
-                                        (* The return address *)
+  (if f.fun_contains_calls && abi = PowerOpen then size_int else 0)
+                                            (* The return address *)
 let frame_size env =
   let size =
-    env.stack_offset +                     (* Trap frame, outgoing parameters *)
+    env.stack_offset +                      (* Trap frame, outgoing parameters *)
     initial_stack_offset env.f in
   Misc.align size 16
 
@@ -54,58 +58,77 @@
       (if cls = 0 then env.f.fun_num_stack_slots.(1) * size_float + n * size_int
                   else n * size_float)
   | Incoming n ->
-    (* Callee's [reserved_stack_space] is included in [frame_size].
-       To access incoming arguments, add caller's [reserverd_stack_space]. *)
+    (* Callee’s [reserved_stack_space] is included in [frame_size].
+       To access incoming arguments, add caller’s [reserverd_stack_space]. *)
       frame_size env + reserved_stack_space + n
   | Outgoing n -> reserved_stack_space + n
   | Domainstate _ -> assert false  (* not a stack slot *)
 
 let retaddr_offset env =
   match abi with
-  | ELF32 -> frame_size env - size_addr
+  | PowerOpen | ELF32 -> frame_size env - size_addr
   | ELF64v1 | ELF64v2 -> frame_size env + 16
 
 let toc_save_offset env =
   match abi with
-  | ELF32 -> assert false
+  | PowerOpen | ELF32 -> assert false
   | ELF64v1 | ELF64v2 -> frame_size env + 8
 
 let (trap_size, trap_handler_offset, trap_previous_offset) =
   match abi with
+  | PowerOpen -> (16, 0, 4)
   | ELF32 -> (16, 0, 4)
   | ELF64v1 -> (32, 56, 64)
   | ELF64v2 -> (32, 40, 48)
 
 (* Output a symbol *)
 
-let emit_symbol s = Emitaux.emit_symbol '.' s
+let emit_symbol s =
+  match Config.system with
+  | "rhapsody" -> emit_char '_'; Emitaux.emit_symbol '$' s
+  | "elf" | "bsd" | "bsd_elf" -> Emitaux.emit_symbol '.' s
 
 (* Output a label *)
 
-let label_prefix = ".L"
+let label_prefix =
+  match Config.system with
+  | "rhapsody" -> "L"
+  | "elf" | "bsd" | "bsd_elf" -> ".L"
 
 let emit_label lbl =
   emit_string label_prefix; emit_int lbl
 
+let emit_data_label lbl =
+  emit_string label_prefix; emit_string "d"; emit_int lbl
+
 (* Section switching *)
 
 let code_space =
-  "	.section \".text\"\n"
+  match Config.system with
+  | "rhapsody"  -> "	.text\n"
+  | "elf" | "bsd" | "bsd_elf" -> "	.section \".text\"\n"
 
 let function_descr_space =
   match abi with
+  | PowerOpen -> code_space
   | ELF32 -> code_space
   | ELF64v1 -> "	.section \".opd\",\"aw\"\n"
   | ELF64v2 -> code_space
 
 let data_space =
-  "	.section \".data\"\n"
+  match Config.system with
+  | "rhapsody" -> "	.data\n"
+  | "elf" | "bsd" | "bsd_elf" -> "	.section \".data\"\n"
 
 let rodata_space =
-  "	.section \".rodata\"\n"
+  match Config.system with
+  | "rhapsody" -> "	.const\n"
+  | "elf" | "bsd" | "bsd_elf" -> "	.section \".rodata\"\n"
 
 let toc_space =
-  " .section \".toc\",\"aw\"\n"
+  match Config.system with
+  | "rhapsody" -> " "
+  | "elf" | "bsd" | "bsd_elf" -> " .section \".toc\",\"aw\"\n"
 
 (* Names of instructions that differ in 32 and 64-bit modes *)
 
@@ -115,13 +138,13 @@
 let cmpg = if ppc64 then "cmpd" else "cmpw"
 let cmplg = if ppc64 then "cmpld" else "cmplw"
 let datag = if ppc64 then ".quad" else ".long"
+let aligng = if ppc64 then 3 else 2
 let mullg = if ppc64 then "mulld" else "mullw"
 let divg = if ppc64 then "divd" else "divw"
 let tglle = if ppc64 then "tdlle" else "twlle"
-
-(* Output a processor register *)
-
-let emit_gpr = emit_int
+let sragi = if ppc64 then "sradi" else "srawi"
+let slgi = if ppc64 then "sldi" else "slwi"
+let fctigz = if ppc64 then "fctidz" else "fctiwz"
 
 (* Output a pseudo-register *)
 
@@ -130,16 +153,29 @@
   | Reg r -> emit_string (register_name r)
   | _ -> Misc.fatal_error "Emit.emit_reg"
 
+let use_full_regnames =
+  Config.system = "rhapsody"
+
+let emit_gpr r =
+  if use_full_regnames then emit_char 'r';
+  emit_int r
+
+let emit_fpr r =
+  if use_full_regnames then emit_char 'f';
+  emit_int r
+
+let emit_ccr r =
+  if use_full_regnames then emit_string "cr";
+  emit_int r
+
 (* Output a stack reference *)
 
 let emit_stack env r =
   match r.loc with
   | Stack (Domainstate n) ->
-      let ofs = n + Domainstate.(idx_of_field Domain_extra_params) * 8 in
-      `{emit_int ofs}(30)`
+      let ofs = n + Domainstate.(idx_of_field Domain_extra_params) * 8 in `{emit_int ofs}({emit_gpr 30})`
   | Stack s ->
-      let ofs = slot_offset env s (register_class r) in
-      `{emit_int ofs}(1)`
+      let ofs = slot_offset env s (register_class r) in `{emit_int ofs}({emit_gpr 1})`
   | _ -> Misc.fatal_error "Emit.emit_stack"
 
 (* Output the name of a symbol plus an optional offset *)
@@ -207,10 +243,10 @@
     tocref_entries
 
 (* Emit a load from a TOC entry.
-
    The [dest] should not be r0, since [dest] is used as the index register for a
    ld instruction, but r0 reads as zero when used as an index register.
 *)
+
 let emit_tocload emit_dest dest entry =
   let lbl = label_for_tocref entry in
   if !big_toc || !Clflags.for_package <> None then begin
@@ -223,10 +259,18 @@
 (* Output a "upper 16 bits" or "lower 16 bits" operator. *)
 
 let emit_upper emit_fun arg =
-  emit_fun arg; emit_string "@ha"
+  match Config.system with
+  | "rhapsody" ->
+      emit_string "ha16("; emit_fun arg; emit_string ")"
+  | "elf" | "bsd" | "bsd_elf" ->
+      emit_fun arg; emit_string "@ha"
 
 let emit_lower emit_fun arg =
-  emit_fun arg; emit_string "@l"
+  match Config.system with
+  | "rhapsody" ->
+      emit_string "lo16("; emit_fun arg; emit_string ")"
+  | "elf" | "bsd" | "bsd_elf" ->
+      emit_fun arg; emit_string "@l"
 
 (* Output a load or store operation *)
 
@@ -237,9 +281,12 @@
   match addressing_mode with
   | Ibased(s, d) ->
       begin match abi with
+      | PowerOpen ->
+          `	addis	{emit_gpr 11}, 0, {emit_upper emit_symbol_offset (s,d)}\n`;
+          `	{emit_string instr}	{emit_reg arg}, {emit_lower emit_symbol_offset (s,d)}({emit_gpr 11})\n`
       | ELF32 ->
-        `	addis	11, 0, {emit_upper emit_symbol_offset (s,d)}\n`;
-        `	{emit_string instr}	{emit_reg arg}, {emit_lower emit_symbol_offset (s,d)}(11)\n`
+          `	addis	11, 0, {emit_upper emit_symbol_offset (s,d)}\n`;
+          `	{emit_string instr}	{emit_reg arg}, {emit_lower emit_symbol_offset (s,d)}(11)\n`
       | ELF64v1 | ELF64v2 ->
         emit_tocload emit_gpr 11 (TocSym s);
         let (lo, hi) = low_high_s d in
@@ -253,28 +300,41 @@
         end
       end
   | Iindexed ofs ->
-      if is_immediate ofs && valid_offset instr ofs then
-        `	{emit_string instr}	{emit_reg arg}, {emit_int ofs}({emit_reg addr.(n)})\n`
-      else begin
+      begin match abi with
+      | PowerOpen ->
+        if is_immediate ofs && valid_offset instr ofs then
+          `	{emit_string instr}	{emit_reg arg}, {emit_int ofs}({emit_reg addr.(n)})\n`
+        else begin
         let (lo, hi) = low_high_u ofs in
-        `	addis	0, 0, {emit_int hi}\n`;
+          `	addis	{emit_gpr 0}, {emit_gpr 0}, {emit_int hi}\n`;
+        if lo <> 0 then
+          `	ori	{emit_gpr 0}, {emit_gpr 0}, {emit_int lo}\n`;
+          `	{emit_string instr}x	{emit_reg arg}, {emit_reg addr.(n)}, {emit_gpr 0}\n`
+        end
+      | ELF32 | ELF64v1 | ELF64v2 ->
+        if is_immediate ofs && valid_offset instr ofs then
+          `	{emit_string instr}	{emit_reg arg}, {emit_int ofs}({emit_reg addr.(n)})\n`
+        else begin
+        let (lo, hi) = low_high_u ofs in
+          `	addis	0, 0, {emit_int hi}\n`;
         if lo <> 0 then
           `	ori	0, 0, {emit_int lo}\n`;
-        `	{emit_string instr}x	{emit_reg arg}, {emit_reg addr.(n)}, 0\n`
-      end
+          `	{emit_string instr}x	{emit_reg arg}, {emit_reg addr.(n)}, 0\n`
+        end
+     end
   | Iindexed2 ->
       `	{emit_string instr}x	{emit_reg arg}, {emit_reg addr.(n)}, {emit_reg addr.(n+1)}\n`
 
 (* After a comparison, extract the result as 0 or 1 *)
 
 let emit_set_comp cmp res =
-  `	mfcr	0\n`;
+  `	mfcr {emit_gpr 0}\n`;
   let bitnum =
     match cmp with
       Ceq | Cne -> 2
     | Cgt | Cle -> 1
     | Clt | Cge -> 0 in
-`	rlwinm	{emit_reg res}, 0, {emit_int(bitnum+1)}, 31, 31\n`;
+`	rlwinm	{emit_reg res}, {emit_gpr 0}, {emit_int(bitnum+1)}, 31, 31\n`;
   begin match cmp with
     Cne | Cle | Cge -> `	xori	{emit_reg res}, {emit_reg res}, 1\n`
   | _ -> ()
@@ -285,7 +345,7 @@
 let emit_free_frame env =
   let n = frame_size env in
   if n > 0 then
-    `	addi	1, 1, {emit_int n}\n`
+    `	addi {emit_gpr 1}, {emit_gpr 1}, {emit_int n}\n`
 
 (* Emit a "bl" instruction to a given symbol *)
 
@@ -300,7 +360,7 @@
 
 let emit_call_nop () =
   match abi with
-  | ELF32 -> ()
+  | PowerOpen | ELF32 -> ()
   | ELF64v1 | ELF64v2 -> `	nop	\n`
 
 (* Reload the TOC register r2 from the value saved on the stack *)
@@ -333,6 +393,23 @@
     ~live_offset:!live_offset dbg;
   `{emit_label lbl}:\n`
 
+(* Record floating-point and large integer literals *)
+
+let float_literals = ref ([] : (int64 * int) list)
+let int_literals = ref ([] : (nativeint * int) list)
+
+(* Record external C functions to be called in a position-independent way for MacOS X *)
+
+let pic_externals = (Config.system = "rhapsody")
+
+let external_functions = ref StringSet.empty
+
+let emit_external s =
+  `	.non_lazy_symbol_pointer\n`;
+  `L{emit_symbol s}$non_lazy_ptr:\n`;
+  `	.indirect_symbol {emit_symbol s}\n`;
+  `	{emit_string datag}	0\n`
+
 (* Names for conditional branches after comparisons *)
 
 let branch_for_comparison = function
@@ -415,13 +492,13 @@
 
   let size =
     match abi with
-    | ELF32 -> (fun a _ _ -> a)
+    | PowerOpen | ELF32 -> (fun a _ _ -> a)
     | ELF64v1 -> (fun _ b _ -> b)
     | ELF64v2 -> (fun _ _ c -> c)
 
   let profiling_prologue_size () =
     match abi with
-    | ELF32 -> 5
+    | PowerOpen | ELF32 -> 5
     | ELF64v1 | ELF64v2 -> 6
 
   let prologue_size f =
@@ -430,16 +507,19 @@
       + (if f.fun_contains_calls then
            2 +
              match abi with
-             | ELF32 -> 0
+             | PowerOpen | ELF32 -> 0
              | ELF64v1 | ELF64v2 -> 1
          else 0)
 
   let tocload_size() =
-    if !big_toc || !Clflags.for_package <> None then 2 else 1
+    match Config.system with
+    | "elf" | "bsd" | "bsd_elf" ->
+      if !big_toc || !Clflags.for_package <> None then 2 else 1
+    | "rhapsody" -> 0
 
   let load_store_size = function
     | Ibased(_s, d) ->
-        if abi = ELF32 then 2 else begin
+        if abi = PowerOpen then 2 else begin
           let (_lo, hi) = low_high_s d in
           tocload_size() + (if hi = 0 then 1 else 2)
         end
@@ -457,18 +537,18 @@
       else if (let (_lo, hi) = native_low_high_u n in
                hi >= -0x8000 && hi <= 0x7FFF) then 2
       else tocload_size()
-    | Lop(Iconst_float _) -> if abi = ELF32 then 2 else tocload_size()
-    | Lop(Iconst_symbol _) -> if abi = ELF32 then 2 else tocload_size()
+    | Lop(Iconst_float _) -> if pic_externals then 2 else tocload_size()
+    | Lop(Iconst_symbol _) -> if pic_externals then 2 else tocload_size()
     | Lop(Icall_ind) -> size 2 5 4
     | Lop(Icall_imm _) -> size 1 3 3
     | Lop(Itailcall_ind) -> size 5 7 6
     | Lop(Itailcall_imm { func; _ }) ->
-        if func = f.fun_name
-        then 1
+        if func = f.fun_name then 1
         else size 4 (7 + tocload_size()) (6 + tocload_size())
     | Lop(Iextcall { alloc = true; _ }) ->
-      size 3 (2 + tocload_size()) (2 + tocload_size())
-    | Lop(Iextcall { alloc = false; _}) -> size 1 2 2
+      if pic_externals then 3
+      else size 3 (2 + tocload_size()) (2 + tocload_size())
+    | Lop(Iextcall { alloc = false; _}) -> size 4 2 2
     | Lop(Istackoffset _) -> 1
     | Lop(Iload(chunk, addr, _mut)) ->
       if chunk = Byte_signed
@@ -500,10 +580,16 @@
       1 + (if lbl0 = None then 0 else 1)
         + (if lbl1 = None then 0 else 1)
         + (if lbl2 = None then 0 else 1)
-    | Lswitch _ -> size 7 (5 + tocload_size()) (5 + tocload_size())
-    | Lentertrap -> size 0 (tocload_size()) (tocload_size())
+    | Lswitch _ ->
+      if pic_externals then 8
+      else size 7 (5 + tocload_size()) (5 + tocload_size())
+    | Lentertrap ->
+      if pic_externals then 1
+      else size 0 (tocload_size()) (tocload_size())
     | Ladjust_trap_depth _ -> 0
-    | Lpushtrap _ -> size 5 (4 + tocload_size()) (4 + tocload_size())
+    | Lpushtrap _ ->
+      if pic_externals then 4
+      else size 5 (4 + tocload_size()) (4 + tocload_size())
     | Lpoptrap -> 2
     | Lraise _ -> 6
 
@@ -525,26 +611,26 @@
 let emit_alloc env i bytes dbginfo far =
   if env.call_gc_label = 0 then env.call_gc_label <- new_label ();
   let offset = Domainstate.(idx_of_field Domain_young_limit) * 8 in
-  `	{emit_string lg}	0, {emit_int offset}(30)\n`;
-  `	addi    31, 31, {emit_int(-bytes)}\n`;
-  `	{emit_string cmplg}	31, 0\n`;
+  `	{emit_string lg}	{emit_gpr 0}, {emit_int offset}({emit_gpr 30})\n`;
+  `	addi    {emit_gpr 31}, {emit_gpr 31}, {emit_int(-bytes)}\n`;
+  `	{emit_string cmplg}	{emit_gpr 31}, {emit_gpr 30}\n`;
   if not far then begin
     `	bltl	{emit_label env.call_gc_label}\n`;
     record_frame env i.live (Dbg_alloc dbginfo);
-    `	addi	{emit_reg i.res.(0)}, 31, {emit_int size_addr}\n`
+    `	addi	{emit_reg i.res.(0)}, {emit_gpr 31}, {emit_int size_addr}\n`
   end else begin
     let lbl = new_label() in
     `	bge	{emit_label lbl}\n`;
     `	bl	{emit_label env.call_gc_label}\n`;
     record_frame env i.live (Dbg_alloc dbginfo);
-    `{emit_label lbl}:	addi	{emit_reg i.res.(0)}, 31, {emit_int size_addr}\n`
+    `{emit_label lbl}:	addi	{emit_reg i.res.(0)}, {emit_gpr 31}, {emit_int size_addr}\n`
   end
 
 let emit_poll env i return_label far =
   if env.call_gc_label = 0 then env.call_gc_label <- new_label ();
   let offset = Domainstate.(idx_of_field Domain_young_limit) * 8 in
-  `	{emit_string lg}	0, {emit_int offset}(30)\n`;
-  `	{emit_string cmplg}	31, 0\n`;
+  `	{emit_string lg}	{emit_gpr 0}, {emit_int offset}({emit_gpr 30})\n`;
+  `	{emit_string cmplg}	{emit_gpr 31}, {emit_gpr 30}\n`;
   if not far then begin
     begin match return_label with
     | None ->
@@ -580,16 +666,16 @@
       assert (env.f.fun_prologue_required);
       let n = frame_size env in
       if n > 0 then begin
-        `	addi	1, 1, {emit_int(-n)}\n`;
+        `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int(-n)}\n`;
         cfi_adjust_cfa_offset n
       end;
       if env.f.fun_contains_calls then begin
         let ra = retaddr_offset env in
-        `	mflr	0\n`;
-        `	{emit_string stg}	0, {emit_int ra}(1)\n`;
+        `	mflr	{emit_gpr 0}\n`;
+        `	{emit_string stg}	{emit_gpr 0}, {emit_int ra}({emit_gpr 1})\n`;
         cfi_offset ~reg: 65 (* LR *) ~offset: (ra - n);
         match abi with
-        | ELF32 -> ()
+        | PowerOpen | ELF32 -> ()
         | ELF64v1 | ELF64v2 ->
           `	std	2, {emit_int(toc_save_offset env)}(1)\n`
       end
@@ -632,12 +718,17 @@
           `	ori	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, {emit_int lo}\n`
         end else begin
           match abi with
-          | ELF32 -> assert false
+          | PowerOpen | ELF32 -> assert false
           | ELF64v1 | ELF64v2 ->
               emit_tocload emit_reg i.res.(0) (TocInt n)
         end end end
     | Lop(Iconst_float f) ->
         begin match abi with
+        | PowerOpen ->
+          let lbl = new_label() in
+          env.float_literals <- { fl=f; lbl } :: env.float_literals;
+          `	addis	{emit_gpr 11}, 0, {emit_upper emit_label lbl}\n`;
+          `	lfd	{emit_reg i.res.(0)}, {emit_lower emit_label lbl}({emit_gpr 11})\n`
         | ELF32 ->
           let lbl = new_label() in
           env.float_literals <- { fl=f; lbl } :: env.float_literals;
@@ -655,7 +746,7 @@
         end
     | Lop(Iconst_symbol s) ->
         begin match abi with
-        | ELF32 ->
+        | PowerOpen | ELF32 ->
           `	addis	{emit_reg i.res.(0)}, 0, {emit_upper emit_symbol s}\n`;
           `	addi	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, {emit_lower emit_symbol s}\n`
         | ELF64v1 | ELF64v2 ->
@@ -663,7 +754,7 @@
         end
     | Lop(Icall_ind) ->
         begin match abi with
-        | ELF32 ->
+        | PowerOpen | ELF32 ->
           `	mtctr	{emit_reg i.arg.(0)}\n`;
           `	bctrl\n`;
           record_frame env i.live (Dbg_other i.dbg)
@@ -683,27 +774,27 @@
         end
     | Lop(Icall_imm { func; }) ->
         begin match abi with
-        | ELF32 ->
+        | PowerOpen | ELF32 ->
             emit_call func;
             record_frame env i.live (Dbg_other i.dbg)
         | ELF64v1 | ELF64v2 ->
-        (* For PPC64, we cannot just emit a "bl s; nop" sequence, because
+        (* For PPC64ELF, we cannot just emit a "bl s; nop" sequence, because
            of the following scenario:
-              - current function f1 calls f2 that has the same TOC
-              - f2 tailcalls f3 that has a different TOC
-           Because f1 and f2 have the same TOC, the linker inserted no
-           code in f1 to save and restore r2 around the call to f2.
-           Because f2 tailcalls f3, r2 will not be restored to f2's TOC
+              – current function f1 calls f2 that has the same TOC
+              – f2 tailcalls f3 that has a different TOC
+           Because f1 and f2 have the same TOC, the linker inserted
+           no code in f1 to save and restore r2 around the call to f2.
+           Because f2 tailcalls f3, r2 will not be restored to f2’s TOC
            when f3 returns.  So, we're back into f1, with the wrong TOC in r2.
            We have two options:
-             1- Turn the call into an indirect call, like we do for
+             1. Turn the call into an indirect call, like we do for
                 Itailcall_imm.  Cost: 6 instructions.
-             2- Follow the "bl" with an instruction to restore r2
+             2. Follow the "bl" with an instruction to restore r2
                 explicitly.  If the called function has a different TOC,
                 this instruction is redundant with those inserted
                 by the linker, but this is harmless.
                 Cost: 3 instructions if same TOC, 7 if different TOC.
-           Let's try option 2. *)
+           Let’s try option 2. *)
             emit_call func;
             record_frame env i.live (Dbg_other i.dbg);
             `	nop\n`;
@@ -711,7 +802,7 @@
         end
     | Lop(Itailcall_ind) ->
         begin match abi with
-        | ELF32 ->
+        | PowerOpen | ELF32 ->
           `	mtctr	{emit_reg i.arg.(0)}\n`
         | ELF64v1 ->
           `	ld	0, 0({emit_reg i.arg.(0)})\n`;  (* code pointer *)
@@ -719,11 +810,11 @@
           `	ld	2, 8({emit_reg i.arg.(0)})\n`   (* TOC for callee *)
         | ELF64v2 ->
           `	mtctr	{emit_reg i.arg.(0)}\n`;
-          `	mr	12, {emit_reg i.arg.(0)}\n`   (* addr of fn in r12 *)
+          `	mr	12, {emit_reg i.arg.(0)}\n`     (* addr of fn in r12 *)
         end;
         if env.f.fun_contains_calls then begin
-          `	{emit_string lg}	11, {emit_int(retaddr_offset env)}(1)\n`;
-          `	mtlr	11\n`
+          `	{emit_string lg}	{emit_gpr 11}, {emit_int(retaddr_offset env)}({emit_gpr 1})\n`;
+          `	mtlr	{emit_gpr 11}\n`
         end;
         emit_free_frame env;
         `	bctr\n`
@@ -732,8 +823,7 @@
           `	b	{emit_label env.f.fun_tailrec_entry_point_label}\n`
         else begin
           begin match abi with
-          | ELF32 ->
-            ()
+          | PowerOpen | ELF32 -> ()
           | ELF64v1 ->
             emit_tocload emit_gpr 11 (TocSym func);
             `	ld	0, 0(11)\n`;  (* code pointer *)
@@ -744,12 +834,12 @@
             `	mtctr	12\n`
           end;
           if env.f.fun_contains_calls then begin
-            `	{emit_string lg}	11, {emit_int(retaddr_offset env)}(1)\n`;
-            `	mtlr	11\n`
+            `	{emit_string lg}	{emit_gpr 11}, {emit_int(retaddr_offset env)}({emit_gpr 1})\n`;
+            `	mtlr	{emit_gpr 11}\n`
           end;
           emit_free_frame env;
           begin match abi with
-          | ELF32 ->
+          | PowerOpen | ELF32 ->
             `	b	{emit_symbol func}\n`
           | ELF64v1 | ELF64v2 ->
             `	bctr\n`
@@ -757,10 +847,24 @@
         end
     | Lop(Iextcall { func; alloc; }) ->
         if not alloc then begin
-          emit_call func;
-          emit_call_nop()
+          if pic_externals then begin
+            external_functions := StringSet.add func !external_functions;
+            `	addis	{emit_gpr 11}, 0, ha16(L{emit_symbol func}$non_lazy_ptr)\n`;
+            `	{emit_string lg}	{emit_gpr 11}, lo16(L{emit_symbol func}$non_lazy_ptr)({emit_gpr 11})\n`;
+            `	mtctr	{emit_gpr 11}\n`;
+            `	bctrl\n`
+          end else begin
+            emit_call func;
+            emit_call_nop()
+            end
         end else begin
           match abi with
+          | PowerOpen ->
+            external_functions := StringSet.add func !external_functions;
+            `	addis	{emit_gpr 11}, 0, ha16(L{emit_symbol func}$non_lazy_ptr)\n`;
+            `	{emit_string lg}	{emit_gpr 11}, lo16(L{emit_symbol func}$non_lazy_ptr)({emit_gpr 11})\n`;
+            emit_call "caml_c_call";
+            record_frame env i.live (Dbg_other i.dbg)
           | ELF32 ->
             `	addis	25, 0, {emit_upper emit_symbol func}\n`;
             `	addi	25, 25, {emit_lower emit_symbol func}\n`;
@@ -773,7 +877,7 @@
             `	nop\n`
         end
     | Lop(Istackoffset n) ->
-        `	addi	1, 1, {emit_int (-n)}\n`;
+        `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int (-n)}\n`;
         adjust_stack_offset env n
     | Lop(Iload(chunk, addr, _mut)) ->
         let loadinstr =
@@ -811,9 +915,9 @@
     | Lop(Iintop Isub) ->               (* subfc has swapped arguments *)
         `	subfc	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}\n`
     | Lop(Iintop Imod) ->
-        `	{emit_string divg}	0, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
-        `	{emit_string mullg}	0, 0, {emit_reg i.arg.(1)}\n`;
-        `	subfc	{emit_reg i.res.(0)}, 0, {emit_reg i.arg.(0)}\n`
+        `	{emit_string divg}	{emit_gpr 0}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
+        `	{emit_string mullg}	{emit_gpr 0}, {emit_gpr 0}, {emit_reg i.arg.(1)}\n`;
+        `	subfc	{emit_reg i.res.(0)}, {emit_gpr 0}, {emit_reg i.arg.(0)}\n`
     | Lop(Iintop(Icomp cmp)) ->
         begin match cmp with
           Isigned c ->
@@ -857,33 +961,33 @@
     | Lop(Ifloatofint) ->
 	if ppc64 then begin
           (* Can use protected zone (288 bytes below r1 *)
-	  `	std	{emit_reg i.arg.(0)}, -16(1)\n`;
-          `	lfd	{emit_reg i.res.(0)}, -16(1)\n`;
+	  `	std	{emit_reg i.arg.(0)}, -16({emit_gpr 1})\n`;
+          `	lfd	{emit_reg i.res.(0)}, -16({emit_gpr 1})\n`;
           `	fcfid	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}\n`
 	end else begin
           let lbl = new_label() in
           env.float_literals <- {fl=0x4330000080000000L; lbl} :: env.float_literals;
-          `	addis	11, 0, {emit_upper emit_label lbl}\n`;
-          `	lfd	0, {emit_lower emit_label lbl}(11)\n`;
-          `	lis	0, 0x4330\n`;
-          `	stwu	0, -16(1)\n`;
-          `	xoris	0, {emit_reg i.arg.(0)}, 0x8000\n`;
-          `	stw	0, 4(1)\n`;
-          `	lfd	{emit_reg i.res.(0)}, 0(1)\n`;
-          `	addi	1, 1, 16\n`;
-          `	fsub	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 0\n`
+          `	addis	{emit_gpr 11}, 0, {emit_upper emit_label lbl}\n`;
+          `	lfd		{emit_fpr 0}, {emit_lower emit_label lbl}({emit_gpr 11})\n`;
+          `	lis		{emit_gpr 0}, 0x4330\n`;
+          `	stwu	{emit_gpr 0}, -16({emit_gpr 1})\n`;
+          `	xoris	{emit_gpr 0}, {emit_reg i.arg.(0)}, 0x8000\n`;
+          `	stw		{emit_gpr 0}, 4({emit_gpr 1})\n`;
+          `	lfd		{emit_reg i.res.(0)}, 0({emit_gpr 1})\n`;
+          `	addi	{emit_gpr 1}, {emit_gpr 1}, 16\n`;
+          `	fsub	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, {emit_fpr 0}\n`
 	end
     | Lop(Iintoffloat) ->
         if ppc64 then begin
           (* Can use protected zone (288 bytes below r1 *)
-          `	fctidz	0, {emit_reg i.arg.(0)}\n`;
-          `	stfd	0, -16(1)\n`;
-          `	ld	{emit_reg i.res.(0)}, -16(1)\n`
+          `	fctidz	{emit_fpr 0}, {emit_reg i.arg.(0)}\n`;
+          `	stfd	{emit_fpr 0}, -16({emit_gpr 1})\n`;
+          `	ld		{emit_reg i.res.(0)}, -16({emit_gpr 1})\n`
         end else begin
-          `	fctiwz	0, {emit_reg i.arg.(0)}\n`;
-          `	stfdu	0, -16(1)\n`;
-          `	lwz	{emit_reg i.res.(0)}, 4(1)\n`;
-          `	addi	1, 1, 16\n`
+          `	fctiwz	{emit_fpr 0}, {emit_reg i.arg.(0)}\n`;
+          `	stfdu	{emit_fpr 0}, -16({emit_gpr 1})\n`;
+          `	lwz		{emit_reg i.res.(0)}, 4({emit_gpr 1})\n`;
+          `	addi	{emit_gpr 1}, {emit_gpr 1}, 16\n`
         end
     | Lop(Iopaque) ->
         assert (i.arg.(0).loc = i.res.(0).loc)
@@ -891,8 +995,8 @@
         let instr = name_for_specific sop in
         `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`
     | Lreloadretaddr ->
-        `	{emit_string lg}	11, {emit_int(retaddr_offset env)}(1)\n`;
-        `	mtlr	11\n`
+        `	{emit_string lg}	{emit_gpr 11}, {emit_int(retaddr_offset env)}({emit_gpr 1})\n`;
+        `	mtlr	{emit_gpr 11}\n`
     | Lreturn ->
         emit_free_frame env;
         `	blr\n`
@@ -917,7 +1021,7 @@
             `	{emit_string comp}i	{emit_reg i.arg.(0)}, {emit_int n}\n`;
             `	{emit_string branch}	{emit_label lbl}\n`
         | Ifloattest cmp -> begin
-            `	fcmpu	0, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
+            `	fcmpu	{emit_ccr 0}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
             (* bit 0 = lt, bit 1 = gt, bit 2 = eq *)
             let bitnum =
               match cmp with
@@ -938,10 +1042,10 @@
                `	bt	{emit_int bitnum}, {emit_label lbl}\n`
           end
         | Ioddtest ->
-            `	andi.	0, {emit_reg i.arg.(0)}, 1\n`;
+            `	andi. {emit_gpr 0}, {emit_reg i.arg.(0)}, 1\n`;
             `	bne	{emit_label lbl}\n`
         | Ieventest ->
-            `	andi.	0, {emit_reg i.arg.(0)}, 1\n`;
+            `	andi. {emit_gpr 0}, {emit_reg i.arg.(0)}, 1\n`;
             `	beq	{emit_label lbl}\n`
         end
     | Lcondbranch3(lbl0, lbl1, lbl2) ->
@@ -960,7 +1064,25 @@
         end
     | Lswitch jumptbl ->
         let lbl = new_label() in
-        if ppc64 then begin
+        begin match abi with
+        | PowerOpen ->
+          begin
+          `	addis	{emit_gpr 11}, 0, {emit_upper emit_label lbl}\n`;
+          `	addi	{emit_gpr 11}, {emit_gpr 11}, {emit_lower emit_label lbl}\n`;
+          `	{emit_string slgi}	{emit_gpr 0}, {emit_reg i.arg.(0)}, 2\n`;
+          `	{emit_string lwa}x	{emit_gpr 0}, {emit_gpr 11}, {emit_gpr 0}\n`;
+          `	add	{emit_gpr 0}, {emit_gpr 11}, {emit_gpr 0}\n`;
+          `	mtctr	{emit_gpr 0}\n`;
+          `	bctr\n`;
+          emit_string rodata_space;
+          `{emit_label lbl}:`;
+          for i = 0 to Array.length jumptbl - 1 do
+          `	.long	{emit_label jumptbl.(i)} - {emit_label lbl}\n`
+          done;
+          emit_string code_space
+        end
+        | ELF32 | ELF64v1 | ELF64v2 -> 
+          if ppc64 then begin
           let jumptables_lbl = match env.jumptables_lbl with
             | None ->
               env.jumptables_lbl <- Some lbl;
@@ -975,34 +1097,41 @@
           if start_hi <> 0 then
             `	addis	12, 12, {emit_int start_hi}\n`;
           `	sldi	12, 12, 2\n`
-        end else begin
+          end else begin
           `	addis	11, 0, {emit_upper emit_label lbl}\n`;
           `	addi	11, 11, {emit_lower emit_label lbl}\n`;
           `	slwi	12, {emit_reg i.arg.(0)}, 2\n`
-        end;
-        `	{emit_string lwa}x	0, 11, 12\n`;
-        `	add	0, 11, 0\n`;
-        `	mtctr	0\n`;
-        `	bctr\n`;
-        if ppc64 then begin
+          end;
+          `	{emit_string lwa}x	0, 11, 12\n`;
+          `	add	0, 11, 0\n`;
+          `	mtctr	0\n`;
+          `	bctr\n`;
+          if ppc64 then begin
           env.jumptables <- List.rev_append (Array.to_list jumptbl) env.jumptables
-        end else begin
+          end else begin
           emit_string rodata_space;
           `{emit_label lbl}:`;
           for i = 0 to Array.length jumptbl - 1 do
             `	.long	{emit_label jumptbl.(i)} - {emit_label lbl}\n`
           done;
           emit_string code_space
+          end
         end
     | Lentertrap ->
         begin match abi with
-        | ELF32 -> ()
+        | PowerOpen | ELF32 -> ()
         | ELF64v1 | ELF64v2 -> emit_reload_toc env
         end
     | Ladjust_trap_depth { delta_traps } ->
         adjust_stack_offset env (trap_size * delta_traps)
     | Lpushtrap { lbl_handler; } ->
         begin match abi with
+        | PowerOpen ->
+          adjust_stack_offset env trap_size;
+          `	mflr	{emit_gpr 0}\n`;
+          `	{emit_string stg}u	{emit_gpr 0}, -16({emit_gpr 1})\n`;
+          `	{emit_string stg}	{emit_gpr 29}, {emit_int size_addr}({emit_gpr 1})\n`;
+          `	mr	{emit_gpr 29}, {emit_gpr 1}\n`
         | ELF32 ->
           `	addis	11, 0, {emit_upper emit_label lbl_handler}\n`;
           `	addi	11, 11, {emit_lower emit_label lbl_handler}\n`;
@@ -1015,21 +1144,22 @@
           adjust_stack_offset env trap_size;
           `	std	29, {emit_int trap_previous_offset}(1)\n`;
           emit_tocload emit_gpr 29 (TocLabel lbl_handler);
-          `	std     29, {emit_int trap_handler_offset}(1)\n`;
+          `	std 29, {emit_int trap_handler_offset}(1)\n`;
           `	mr	29, 1\n`
           end
     | Lpoptrap ->
-        `	{emit_string lg}	29, {emit_int trap_previous_offset}(1)\n`;
-        `	addi	1, 1, {emit_int trap_size}\n`;
+          `	{emit_string lg}	{emit_gpr 29}, {emit_int trap_previous_offset}({emit_gpr 1})\n`;
+          `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int trap_size}\n`;
         adjust_stack_offset env (-trap_size)
     | Lraise k ->
         begin match k with
         | Lambda.Raise_regular ->
-            `	li	0, 0\n`;
+            `	li	{emit_gpr 0}, 0\n`;
             let backtrace_pos =
               Domainstate.(idx_of_field Domain_backtrace_pos)
             in
             begin match abi with
+            | PowerOpen ->  `	stw	{emit_gpr 0}, {emit_int (backtrace_pos * 8)}({emit_gpr 30})\n`
             | ELF32 -> `	stw	0, {emit_int (backtrace_pos * 8)}(30)\n`
             | _ -> `	std	0, {emit_int (backtrace_pos * 8)}(30)\n`
             end;
@@ -1041,11 +1171,11 @@
             record_frame env Reg.Set.empty (Dbg_raise i.dbg);
             emit_call_nop()
         | Lambda.Raise_notrace ->
-            `	{emit_string lg}	0, {emit_int trap_handler_offset}(29)\n`;
-            `	mr	1, 29\n`;
-            `	mtctr   0\n`;
-            `	{emit_string lg}	29, {emit_int trap_previous_offset}(1)\n`;
-            `	addi	1, 1, {emit_int trap_size}\n`;
+            `	{emit_string lg}	{emit_gpr 0}, {emit_int trap_handler_offset}({emit_gpr 29})\n`;
+            `	mr	{emit_gpr 1}, {emit_gpr 29}\n`;
+            `	mtctr   {emit_gpr 0}\n`;
+            `	{emit_string lg}	{emit_gpr 29}, {emit_int trap_previous_offset}({emit_gpr 1})\n`;
+            `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int trap_size}\n`;
             `	bctr\n`
         end
 
@@ -1061,6 +1191,18 @@
 let fundecl fundecl =
   let env = mk_env fundecl in
   begin match abi with
+  | PowerOpen ->
+    emit_string code_space;
+    if not !Clflags.output_c_object && is_generic_function fundecl.fun_name
+    then (* PR#4690 *)
+    `	.private_extern	{emit_symbol fundecl.fun_name}\n`
+    else
+    `	.globl	{emit_symbol fundecl.fun_name}\n`;
+    if ppc64 then
+    `	.align	3\n`
+    else
+    `	.align	2\n`;
+    `{emit_symbol fundecl.fun_name}:\n`;
   | ELF32 ->
     emit_string code_space;
     `	.globl	{emit_symbol fundecl.fun_name}\n`;
@@ -1089,16 +1231,15 @@
   end;
   emit_debug_info fundecl.fun_dbg;
   cfi_startproc();
-  (* On this target, there is at most one "out of line" code block per
-     function: a single "call GC" point.  It comes immediately after the
-     function's body. *)
+  (* On this target, there is at most one "out of line" code block per function:
+     a single "call GC" point. It comes immediately after the function’s body. *)
   BR.relax fundecl ~max_out_of_line_code_offset:0;
   emit_all env fundecl.fun_body;
   (* Emit the glue code to call the GC *)
   if env.call_gc_label > 0 then begin
     `{emit_label env.call_gc_label}:\n`;
     match abi with
-    | ELF32 ->
+    | PowerOpen | ELF32 ->
       `	b	{emit_symbol "caml_call_gc"}\n`
     | ELF64v1 ->
       `	std	2, 40(1)\n`;
@@ -1117,6 +1258,7 @@
   end;
   cfi_endproc();
   begin match abi with
+  | PowerOpen -> ()
   | ELF32 | ELF64v2 ->
     `	.size	{emit_symbol fundecl.fun_name}, . - {emit_symbol fundecl.fun_name}\n`
   | ELF64v1 ->
@@ -1149,7 +1291,10 @@
 
 let declare_global_data s =
   `	.globl	{emit_symbol s}\n`;
-  `	.type	{emit_symbol s}, @object\n`
+  match Config.system with
+  | "elf" | "bsd" | "bsd_elf" ->
+    `	.type	{emit_symbol s}, @object\n`
+  | "rhapsody" -> ()
 
 let emit_item = function
     Cglobal_symbol s ->
@@ -1213,6 +1358,9 @@
   `{emit_symbol lbl_begin}:\n`
 
 let end_assembly() =
+  if pic_externals then
+    (* Emit the pointers to external functions *)
+    StringSet.iter emit_external !external_functions;
   (* Emit the end of the segments *)
   emit_string function_descr_space;
   let lbl_end = Compilenv.make_symbol (Some "code_end") in
@@ -1232,26 +1380,24 @@
   declare_global_data lbl;
   `{emit_symbol lbl}:\n`;
   emit_frames
-    { efa_code_label =
-         (fun l -> `	{emit_string datag}	{emit_label l}\n`);
-      efa_data_label =
-         (fun l -> `	{emit_string datag}	{emit_label l}\n`);
+    { efa_code_label = (fun l -> `	{emit_string datag}	{emit_label l}\n`);
+      efa_data_label = (fun l -> `	{emit_string datag}	{emit_label l}\n`);
       efa_8 = (fun n -> `	.byte	{emit_int n}\n`);
       efa_16 = (fun n -> `	.short	{emit_int n}\n`);
       efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
       efa_word = (fun n -> `	{emit_string datag}	{emit_int n}\n`);
       efa_align = (fun n -> `	.balign	{emit_int n}\n`);
-      efa_label_rel = (fun lbl ofs ->
-                           `	.long	({emit_label lbl} - .) + {emit_int32 ofs}\n`);
+      efa_label_rel = (fun lbl ofs -> `	.long	({emit_label lbl} - .) + {emit_int32 ofs}\n`);
       efa_def_label = (fun l -> `{emit_label l}:\n`);
       efa_string = (fun s -> emit_bytes_directive "	.byte	" (s ^ "\000"))
      };
   (* Emit the TOC entries *)
   begin match abi with
-  | ELF32 -> ()
+  | PowerOpen | ELF32 -> ()
   | ELF64v1 | ELF64v2 ->
       emit_string toc_space;
       emit_toctable();
       Hashtbl.clear tocref_entries
   end;
+  if not pic_externals then
   `	.section .note.GNU-stack,\"\",%progbits\n`

