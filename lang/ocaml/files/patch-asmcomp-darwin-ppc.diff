--- asmcomp/power/proc.ml.orig	2022-03-28 20:27:36.000000000 +0800
+++ asmcomp/power/proc.ml	2022-04-30 06:01:01.000000000 +0800
@@ -45,11 +45,22 @@
 *)
 
 let int_reg_name =
+  if Config.system = "rhapsody" then
+    [| "r3"; "r4"; "r5"; "r6"; "r7"; "r8"; "r9"; "r10";
+       "r14"; "r15"; "r16"; "r17"; "r18"; "r19"; "r20"; "r21";
+       "r22"; "r23"; "r24"; "r25"; "r26"; "r27"; "r28" |]
+  else
   [| "3"; "4"; "5"; "6"; "7"; "8"; "9"; "10";           (* 0 - 7 *)
      "14"; "15"; "16"; "17"; "18"; "19"; "20"; "21";    (* 8 - 15 *)
      "22"; "23"; "24"; "25"; "26"; "27"; "28" |]        (* 16 - 22 *)
 
 let float_reg_name =
+  if Config.system = "rhapsody" then
+    [| "f1"; "f2"; "f3"; "f4"; "f5"; "f6"; "f7"; "f8";
+       "f9"; "f10"; "f11"; "f12"; "f13"; "f14"; "f15"; "f16";
+       "f17"; "f18"; "f19"; "f20"; "f21"; "f22"; "f23"; "f24";
+       "f25"; "f26"; "f27"; "f28"; "f29"; "f30"; "f31" |]
+  else
   [| "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8";
      "9"; "10"; "11"; "12"; "13"; "14"; "15"; "16";
      "17"; "18"; "19"; "20"; "21"; "22"; "23"; "24";
@@ -74,8 +85,12 @@
 (* Representation of hard registers by pseudo-registers *)
 
 let hard_int_reg =
-  let v = Array.make 23 Reg.dummy in
-  for i = 0 to 21 do v.(i) <- Reg.at_location Int (Reg i) done; v
+  if Config.system = "rhapsody" then
+    let v = Array.make 23 Reg.dummy in
+    for i = 0 to 22 do v.(i) <- Reg.at_location Int (Reg i) done; v
+else
+    let v = Array.make 23 Reg.dummy in
+    for i = 0 to 21 do v.(i) <- Reg.at_location Int (Reg i) done; v
 
 let hard_float_reg =
   let v = Array.make 31 Reg.dummy in
@@ -153,15 +168,9 @@
   done;
   (loc, Misc.align (max 0 !ofs) 16)  (* keep stack 16-aligned *)
 
-let incoming ofs =
-  if ofs >= 0
-  then Incoming ofs
-  else Domainstate (ofs + size_domainstate_args)
-let outgoing ofs =
-  if ofs >= 0
-  then Outgoing ofs
-  else Domainstate (ofs + size_domainstate_args)
-let not_supported _ofs = fatal_error "Proc.loc_results: cannot call"
+let incoming ofs = Incoming ofs
+let outgoing ofs = Outgoing ofs
+let not_supported ofs = fatal_error "Proc.loc_results: cannot call"
 
 let max_arguments_for_tailcalls = 16 (* in regs *) + 64 (* in domain state *)
 
@@ -170,38 +179,25 @@
 
 let loc_parameters arg =
   let (loc, _ofs) =
-    calling_conventions 0 15 100 112 incoming (- size_domainstate_args) arg
-  in loc
+    calling_conventions 0 15 100 112 incoming (- size_domainstate_args) arg in loc
 
 let loc_results res =
-  let (loc, _ofs) = calling_conventions 0 15 100 112 not_supported 0 res
-  in loc
+  let (loc, _ofs) = calling_conventions 0 15 100 112 not_supported 0 res in loc
 
-(* C calling conventions for ELF32:
+(* C calling conventions under PowerOpen:
+     use GPR 3-10 and FPR 1-13 just like ML calling
+     conventions, but always reserve stack space for all arguments.
+     Also, using a float register automatically reserves two int registers
+     (in 32-bit mode) or one int register (in 64-bit mode).
+     (If we were to call a non-prototyped C function, each float argument
+      would have to go both in a float reg and in the matching pair
+      of integer regs.)
+
+   C calling conventions under SVR4:
      use GPR 3-10 and FPR 1-8 just like ML calling conventions.
      Using a float register does not affect the int registers.
      Always reserve 8 bytes at bottom of stack, plus whatever is needed
-     to hold the overflow arguments.
-   C calling conventions for ELF64v1:
-     Use GPR 3-10 for the first integer arguments.
-     Use FPR 1-13 for the first float arguments.
-     Always reserve stack space for all arguments, even when passed in
-     registers.
-     Always reserve at least 8 words (64 bytes) for the arguments.
-     Always reserve 48 bytes at bottom of stack, plus whatever is needed
-     to hold the arguments.
-     The reserved 48 bytes are automatically added in emit.mlp
-     and need not appear here.
-   C calling conventions for ELF64v2:
-     Use GPR 3-10 for the first integer arguments.
-     Use FPR 1-13 for the first float arguments.
-     If all arguments fit in registers, don't reserve stack space.
-     Otherwise, reserve stack space for all arguments.
-     Always reserve 32 bytes at bottom of stack, plus whatever is needed
-     to hold the arguments.
-     The reserved 32 bytes are automatically added in emit.mlp
-     and need not appear here.
-*)
+     to hold the overflow arguments. *)
 
 let external_calling_conventions
     first_int last_int first_float last_float
@@ -230,52 +226,23 @@
   (loc, Misc.align !ofs 16) (* Keep stack 16-aligned *)
 
 let loc_external_arguments ty_args =
-  match abi with
-  | ELF32 ->
+  match Config.system with
+  |  "rhapsody" ->
+      external_calling_conventions 0 7 100 112 outgoing 0 false ty_args
+  | _ ->
       external_calling_conventions 0 7 100 107 outgoing 8 false ty_args
-  | ELF64v1 ->
-      let (loc, ofs) =
-        external_calling_conventions 0 7 100 112 outgoing 0 true ty_args in
-      (loc, max ofs 64)
-  | ELF64v2 ->
-      let (loc, ofs) =
-        external_calling_conventions 0 7 100 112 outgoing 0 true ty_args in
-      if Array.fold_left
-           (fun stk r ->
-              assert (Array.length r = 1);
-              match r.(0).loc with
-              | Stack _ -> true
-              | _ -> stk)
-           false loc
-      then (loc, ofs)
-      else (loc, 0)
+  
+let extcall_use_push = false
 
 (* Results are in GPR 3 and FPR 1 *)
 
 let loc_external_results res =
-  let (loc, _ofs) = calling_conventions 0 1 100 100 not_supported 0 res
-  in loc
+  let (loc, _ofs) = calling_conventions 0 1 100 100 not_supported 0 res in loc
 
 (* Exceptions are in GPR 3 *)
 
 let loc_exn_bucket = phys_reg 0
 
-(* For ELF32 see:
-   "System V Application Binary Interface PowerPC Processor Supplement"
-   http://refspecs.linux-foundation.org/elf/elfspec_ppc.pdf
-
-   For ELF64v1 see:
-   "64-bit PowerPC ELF Application Binary Interface Supplement 1.9"
-   http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html
-
-   For ELF64v2 see:
-   "64-Bit ELF V2 ABI Specification -- Power Architecture"
-   http://openpowerfoundation.org/wp-content/uploads/resources/leabi/
-     content/dbdoclet.50655239___RefHeading___Toc377640569.html
-
-   All of these specifications seem to agree on the numberings we need.
-*)
-
 let int_dwarf_reg_numbers =
   [| 3; 4; 5; 6; 7; 8; 9; 10;
      14; 15; 16; 17; 18; 19; 20; 21;
@@ -321,40 +288,48 @@
 (* Maximal register pressure *)
 
 let safe_register_pressure = function
-    Iextcall _ -> 14
+    Iextcall _ -> 15
   | _ -> 23
 
 let max_register_pressure = function
-    Iextcall _ -> [| 14; 18 |]
+    Iextcall _ -> [| 15; 18 |]
   | _ -> [| 23; 30 |]
 
+(* Pure operations (without any side effect besides updating their result registers). *)
+
+let op_is_pure = function
+  | Icall_ind | Icall_imm _ | Itailcall_ind | Itailcall_imm _
+  | Iextcall _ | Istackoffset _ | Istore _ | Ialloc _
+  | Iintop(Icheckbound) | Iintop_imm(Icheckbound, _) -> false
+  | Ispecific(Imultaddf | Imultsubf) -> true
+  | Ispecific _ -> false
+  | _ -> true
+
 (* Layout of the stack *)
 
 (* See [reserved_stack_space] in emit.mlp. *)
 let reserved_stack_space_required () =
-  match abi with
-  | ELF32 -> false
-  | ELF64v1 | ELF64v2 -> true
+  match Config.system with
+  | "rhapsody" -> false
+  | _ -> false
 
 let frame_required fd =
-  let is_elf32 =
-    match abi with
-    | ELF32 -> true
-    | ELF64v1 | ELF64v2 -> false
+  let is_darwin32 =
+    match Config.system with
+    | "rhapsody" -> true
+    | _ -> false
   in
   reserved_stack_space_required ()
     || fd.fun_num_stack_slots.(0) > 0
     || fd.fun_num_stack_slots.(1) > 0
-    || (fd.fun_contains_calls && is_elf32)
+    || (fd.fun_contains_calls && is_darwin32)
 
-let prologue_required fd =
-  frame_required fd
+let prologue_required fd = frame_required fd
 
 (* Calling the assembler *)
 
 let assemble_file infile outfile =
-  Ccomp.command (Config.asm ^ " " ^
-                 (String.concat " " (Misc.debug_prefix_map_flags ())) ^
-                 " -o " ^ Filename.quote outfile ^ " " ^ Filename.quote infile)
+  Ccomp.command (Config.asm ^ " -o " ^
+                 Filename.quote outfile ^ " " ^ Filename.quote infile)
 
 let init () = ()




--- asmcomp/power/arch.ml.orig	2022-03-28 20:27:36.000000000 +0800
+++ asmcomp/power/arch.ml	2022-04-30 04:07:14.000000000 +0800
@@ -20,16 +20,7 @@
 let ppc64 =
   match Config.model with
   | "ppc" -> false
-  | "ppc64" | "ppc64le" -> true
-  | _ -> assert false
-
-type abi = ELF32 | ELF64v1 | ELF64v2
-
-let abi =
-  match Config.model with
-  | "ppc" -> ELF32
-  | "ppc64" -> ELF64v1
-  | "ppc64le" -> ELF64v2
+  | "ppc64" -> true
   | _ -> assert false
 
 type cmm_label = int
@@ -37,14 +28,7 @@
 
 (* Machine-specific command-line options *)
 
-let big_toc = ref true
-
-let command_line_options = [
-  "-flarge-toc", Arg.Set big_toc,
-     " Support TOC (table of contents) greater than 64 kbytes (default)";
-  "-fsmall-toc", Arg.Clear big_toc,
-     " TOC (table of contents) is limited to 64 kbytes"
-]
+let command_line_options = []
 
 (* Specific operations *)
 
@@ -64,12 +48,7 @@
 
 (* Sizes, endianness *)
 
-let big_endian =
-  match Config.model with
-  | "ppc" -> true
-  | "ppc64" -> true
-  | "ppc64le" -> false
-  | _ -> assert false
+let big_endian = true
 
 let size_addr = if ppc64 then 8 else 4
 let size_int = size_addr



--- asmcomp/power/emit.mlp.orig	2022-03-28 20:27:36.000000000 +0800
+++ asmcomp/power/emit.mlp	2022-04-30 12:18:04.000000000 +0800
@@ -16,6 +16,9 @@
 
 (* Emission of PowerPC assembly code *)
 
+module StringSet =
+  Set.Make(struct type t = string let compare (x:t) y = compare x y end)
+
 open Cmm
 open Arch
 open Proc
@@ -27,11 +30,7 @@
 
 (* Reserved space at bottom of stack *)
 
-let reserved_stack_space =
-  match abi with
-  | ELF32 -> 0
-  | ELF64v1 -> 48
-  | ELF64v2 -> 32
+let reserved_stack_space = 32
 
 (* Layout of the stack.  The stack is kept 16-aligned. *)
 
@@ -39,7 +38,7 @@
   reserved_stack_space +
   size_int * f.fun_num_stack_slots.(0) +    (* Local int variables *)
   size_float * f.fun_num_stack_slots.(1) +  (* Local float variables *)
-  (if f.fun_contains_calls && abi = ELF32 then size_int else 0)
+  (if f.fun_contains_calls then size_int else 0)
                                         (* The return address *)
 let frame_size env =
   let size =
@@ -54,35 +53,36 @@
       (if cls = 0 then env.f.fun_num_stack_slots.(1) * size_float + n * size_int
                   else n * size_float)
   | Incoming n ->
-    (* Callee's [reserved_stack_space] is included in [frame_size].
-       To access incoming arguments, add caller's [reserverd_stack_space]. *)
+    (* Callee’s [reserved_stack_space] is included in [frame_size].
+       To access incoming arguments, add caller’s [reserverd_stack_space]. *)
       frame_size env + reserved_stack_space + n
   | Outgoing n -> reserved_stack_space + n
-  | Domainstate _ -> assert false  (* not a stack slot *)
 
 let retaddr_offset env =
-  match abi with
-  | ELF32 -> frame_size env - size_addr
-  | ELF64v1 | ELF64v2 -> frame_size env + 16
+  match Config.system with
+  | "rhapsody" -> frame_size env - size_addr
+  | _ -> assert false
 
 let toc_save_offset env =
-  match abi with
-  | ELF32 -> assert false
-  | ELF64v1 | ELF64v2 -> frame_size env + 8
+  match Config.system with
+  | "rhapsody" -> assert false
+  | _ -> assert false
 
 let (trap_size, trap_handler_offset, trap_previous_offset) =
-  match abi with
-  | ELF32 -> (16, 0, 4)
-  | ELF64v1 -> (32, 56, 64)
-  | ELF64v2 -> (32, 40, 48)
+  match Config.system with
+  | "rhapsody" -> (16, 0, 4)
+  | _ -> assert false
 
 (* Output a symbol *)
 
-let emit_symbol s = Emitaux.emit_symbol '.' s
+let emit_symbol s = emit_char '_'; Emitaux.emit_symbol '$' s
 
 (* Output a label *)
 
-let label_prefix = ".L"
+let label_prefix =
+  match Config.system with
+  | "rhapsody" -> "L"
+  | _ -> assert false
 
 let emit_label lbl =
   emit_string label_prefix; emit_int lbl
@@ -90,22 +90,13 @@
 (* Section switching *)
 
 let code_space =
-  "	.section \".text\"\n"
-
-let function_descr_space =
-  match abi with
-  | ELF32 -> code_space
-  | ELF64v1 -> "	.section \".opd\",\"aw\"\n"
-  | ELF64v2 -> code_space
+  "	.text\n"
 
 let data_space =
-  "	.section \".data\"\n"
+  "	.data\n"
 
 let rodata_space =
-  "	.section \".rodata\"\n"
-
-let toc_space =
-  " .section \".toc\",\"aw\"\n"
+  "	.const\n"
 
 (* Names of instructions that differ in 32 and 64-bit modes *)
 
@@ -115,9 +106,13 @@
 let cmpg = if ppc64 then "cmpd" else "cmpw"
 let cmplg = if ppc64 then "cmpld" else "cmplw"
 let datag = if ppc64 then ".quad" else ".long"
+let aligng = if ppc64 then 3 else 2
 let mullg = if ppc64 then "mulld" else "mullw"
 let divg = if ppc64 then "divd" else "divw"
 let tglle = if ppc64 then "tdlle" else "twlle"
+let sragi = if ppc64 then "sradi" else "srawi"
+let slgi = if ppc64 then "sldi" else "slwi"
+let fctigz = if ppc64 then "fctidz" else "fctiwz"
 
 (* Output a processor register *)
 
@@ -130,18 +125,31 @@
   | Reg r -> emit_string (register_name r)
   | _ -> Misc.fatal_error "Emit.emit_reg"
 
+let use_full_regnames =
+  Config.system = "rhapsody"
+
+let emit_gpr r =
+  if use_full_regnames then emit_char 'r';
+  emit_int r
+
+let emit_fpr r =
+  if use_full_regnames then emit_char 'f';
+  emit_int r
+
+let emit_ccr r =
+  if use_full_regnames then emit_string "cr";
+  emit_int r
+
 (* Output a stack reference *)
 
 let emit_stack env r =
   match r.loc with
-  | Stack (Domainstate n) ->
-      let ofs = n + Domainstate.(idx_of_field Domain_extra_params) * 8 in
-      `{emit_int ofs}(30)`
   | Stack s ->
-      let ofs = slot_offset env s (register_class r) in
-      `{emit_int ofs}(1)`
+      let ofs = slot_offset env s (register_class r) in `{emit_int ofs}({emit_gpr 1})`
   | _ -> Misc.fatal_error "Emit.emit_stack"
 
+(* Split a 32-bit integer constants in two 16-bit halves *)
+
 (* Output the name of a symbol plus an optional offset *)
 
 let emit_symbol_offset (s, d) =
@@ -176,82 +184,35 @@
 let is_native_immediate n =
   n <= 32767n && n >= -32768n
 
-(* Record TOC entries *)
-
-type tocentry =
-  | TocSym of string
-  | TocLabel of int
-  | TocInt of nativeint
-  | TocFloat of int64
-
-let tocref_entries : (tocentry, label) Hashtbl.t = Hashtbl.create 64
-
-let emit_tocentry = function
-  | TocSym s -> emit_symbol s
-  | TocInt i -> emit_nativeint i
-  | TocFloat f -> emit_printf "0x%Lx # %.12g" f (Int64.float_of_bits f)
-  | TocLabel lbl -> emit_label lbl
-
-let label_for_tocref entry =
-  try
-    Hashtbl.find tocref_entries entry
-  with Not_found ->
-    let lbl = new_label() in
-    Hashtbl.add tocref_entries entry lbl;
-    lbl
-
-let emit_toctable () =
-  Hashtbl.iter
-    (fun entry lbl ->
-      `{emit_label lbl}:	.quad	{emit_tocentry entry}\n`)
-    tocref_entries
-
-(* Emit a load from a TOC entry.
-
-   The [dest] should not be r0, since [dest] is used as the index register for a
-   ld instruction, but r0 reads as zero when used as an index register.
-*)
-let emit_tocload emit_dest dest entry =
-  let lbl = label_for_tocref entry in
-  if !big_toc || !Clflags.for_package <> None then begin
-    `	addis	{emit_dest dest}, 2, {emit_label lbl}@toc@ha\n`;
-    `	ld	{emit_dest dest}, {emit_label lbl}@toc@l({emit_dest dest}) # {emit_tocentry entry}\n`
-  end else begin
-    `	ld	{emit_dest dest}, {emit_label lbl}@toc(2) # {emit_tocentry entry}\n`
-  end
-
-(* Output a "upper 16 bits" or "lower 16 bits" operator. *)
+(* Output a "upper 16 bits" or "lower 16 bits" operator *)
 
 let emit_upper emit_fun arg =
-  emit_fun arg; emit_string "@ha"
+  match Config.system with
+  | "rhapsody" ->
+      emit_string "ha16("; emit_fun arg; emit_string ")"
+  | _ -> assert false
 
 let emit_lower emit_fun arg =
-  emit_fun arg; emit_string "@l"
+  match Config.system with
+  | "rhapsody" ->
+      emit_string "lo16("; emit_fun arg; emit_string ")"
+  | _ -> assert false
 
 (* Output a load or store operation *)
 
+let emit_symbol_offset (s, d) =
+  emit_symbol s;
+  if d > 0 then `+`;
+  if d <> 0 then emit_int d
+
 let valid_offset instr ofs =
   ofs land 3 = 0 || (instr <> "ld" && instr <> "std" && instr <> "lwa")
 
 let emit_load_store instr addressing_mode addr n arg =
   match addressing_mode with
-  | Ibased(s, d) ->
-      begin match abi with
-      | ELF32 ->
-        `	addis	11, 0, {emit_upper emit_symbol_offset (s,d)}\n`;
-        `	{emit_string instr}	{emit_reg arg}, {emit_lower emit_symbol_offset (s,d)}(11)\n`
-      | ELF64v1 | ELF64v2 ->
-        emit_tocload emit_gpr 11 (TocSym s);
-        let (lo, hi) = low_high_s d in
-        if hi <> 0 then
-          `	addis	11, 11, {emit_int hi}\n`;
-        if valid_offset instr lo then
-          `	{emit_string instr}	{emit_reg arg}, {emit_int lo}(11)\n`
-        else begin
-          `	li	0, {emit_int lo}\n`;
-          `	{emit_string instr}x	{emit_reg arg}, 11, 0\n`
-        end
-      end
+    Ibased(s, d) ->
+      `	addis	{emit_gpr 11}, 0, {emit_upper emit_symbol_offset (s,d)}\n`;
+      `	{emit_string instr}	{emit_reg arg}, {emit_lower emit_symbol_offset (s,d)}({emit_gpr 11})\n`
   | Iindexed ofs ->
       if is_immediate ofs && valid_offset instr ofs then
         `	{emit_string instr}	{emit_reg arg}, {emit_int ofs}({emit_reg addr.(n)})\n`
@@ -268,13 +229,13 @@
 (* After a comparison, extract the result as 0 or 1 *)
 
 let emit_set_comp cmp res =
-  `	mfcr	0\n`;
+  `	mfcr	{emit_gpr 0}\n`;
   let bitnum =
     match cmp with
       Ceq | Cne -> 2
     | Cgt | Cle -> 1
     | Clt | Cge -> 0 in
-`	rlwinm	{emit_reg res}, 0, {emit_int(bitnum+1)}, 31, 31\n`;
+`	rlwinm	{emit_reg res}, {emit_gpr 0}, {emit_int(bitnum+1)}, 31, 31\n`;
   begin match cmp with
     Cne | Cle | Cge -> `	xori	{emit_reg res}, {emit_reg res}, 1\n`
   | _ -> ()
@@ -290,23 +251,10 @@
 (* Emit a "bl" instruction to a given symbol *)
 
 let emit_call s =
-  match abi with
-  | ELF32 when !Clflags.dlcode || !Clflags.pic_code ->
-    `	bl	{emit_symbol s}@plt\n`
-  | _ ->
+  match Config.system with
+  | "rhapsody" ->
     `	bl	{emit_symbol s}\n`
-
-(* Add a nop after a "bl" call for ELF64 *)
-
-let emit_call_nop () =
-  match abi with
-  | ELF32 -> ()
-  | ELF64v1 | ELF64v2 -> `	nop	\n`
-
-(* Reload the TOC register r2 from the value saved on the stack *)
-
-let emit_reload_toc env =
-  `	ld	2, {emit_int (toc_save_offset env)}(1)\n`
+  | _ -> assert false
 
 (* Adjust stack_offset and emit corresponding CFI directive *)
 
@@ -333,6 +281,23 @@
     ~live_offset:!live_offset dbg;
   `{emit_label lbl}:\n`
 
+(* Record floating-point and large integer literals *)
+
+let float_literals = ref ([] : (int64 * int) list)
+let int_literals = ref ([] : (nativeint * int) list)
+
+(* Record external C functions to be called in a position-independent way (for MacOSX) *)
+
+let pic_externals = (Config.system = "rhapsody")
+
+let external_functions = ref StringSet.empty
+
+let emit_external s =
+  `	.non_lazy_symbol_pointer\n`;
+  `L{emit_symbol s}$non_lazy_ptr:\n`;
+  `	.indirect_symbol {emit_symbol s}\n`;
+  `	{emit_string datag}	0\n`
+
 (* Names for conditional branches after comparisons *)
 
 let branch_for_comparison = function
@@ -387,6 +352,15 @@
   | Imultsubf -> "fmsub"
   | _ -> Misc.fatal_error "Emit.Ispecific"
 
+(* Name of current function *)
+let function_name = ref ""
+(* Entry point for tail recursive calls *)
+let tailrec_entry_point = ref 0
+(* Names of functions defined in the current file *)
+let defined_functions = ref StringSet.empty
+(* Label of glue code for calling the GC *)
+let call_gc_label = ref 0
+
 (* Relaxation of branches that exceed the span of a relative branch. *)
 
 module BR = Branch_relaxation.Make (struct
@@ -414,35 +388,22 @@
   let offset_pc_at_branch = 1
 
   let size =
-    match abi with
-    | ELF32 -> (fun a _ _ -> a)
-    | ELF64v1 -> (fun _ b _ -> b)
-    | ELF64v2 -> (fun _ _ c -> c)
+    match Config.system with
+    | "rhapsody" -> (fun a _ _ -> a)
+    | _ -> (fun _ b _ -> b)
 
   let profiling_prologue_size () =
-    match abi with
-    | ELF32 -> 5
-    | ELF64v1 | ELF64v2 -> 6
+    match Config.system with
+    | "rhapsody" -> 5
+    | _ -> 6
 
   let prologue_size f =
     profiling_prologue_size ()
       + (if initial_stack_offset f > 0 then 1 else 0)
-      + (if f.fun_contains_calls then
-           2 +
-             match abi with
-             | ELF32 -> 0
-             | ELF64v1 | ELF64v2 -> 1
-         else 0)
-
-  let tocload_size() =
-    if !big_toc || !Clflags.for_package <> None then 2 else 1
+      + (if f.fun_contains_calls then 2 else 0)
 
   let load_store_size = function
-    | Ibased(_s, d) ->
-        if abi = ELF32 then 2 else begin
-          let (_lo, hi) = low_high_s d in
-          tocload_size() + (if hi = 0 then 1 else 2)
-        end
+    | Ibased(_s, d) -> 2
     | Iindexed ofs -> if is_immediate ofs then 1 else 3
     | Iindexed2 -> 1
 
@@ -451,24 +412,15 @@
     | Lprologue -> prologue_size f
     | Lop(Imove | Ispill | Ireload) -> 1
     | Lop(Iconst_int n) ->
-      if is_native_immediate n then 1
-      else if (let (_lo, hi) = native_low_high_s n in
-               hi >= -0x8000 && hi <= 0x7FFF) then 2
-      else if (let (_lo, hi) = native_low_high_u n in
-               hi >= -0x8000 && hi <= 0x7FFF) then 2
-      else tocload_size()
-    | Lop(Iconst_float _) -> if abi = ELF32 then 2 else tocload_size()
-    | Lop(Iconst_symbol _) -> if abi = ELF32 then 2 else tocload_size()
-    | Lop(Icall_ind) -> size 2 5 4
-    | Lop(Icall_imm _) -> size 1 3 3
-    | Lop(Itailcall_ind) -> size 5 7 6
-    | Lop(Itailcall_imm { func; _ }) ->
-        if func = f.fun_name
-        then 1
-        else size 4 (7 + tocload_size()) (6 + tocload_size())
-    | Lop(Iextcall { alloc = true; _ }) ->
-      size 3 (2 + tocload_size()) (2 + tocload_size())
-    | Lop(Iextcall { alloc = false; _}) -> size 1 2 2
+      if is_native_immediate n then 1 else 2
+    | Lop(Iconst_float _) -> 2
+    | Lop(Iconst_symbol _) -> 2
+    | Lop(Icall_ind) -> 2
+    | Lop(Icall_imm _) -> 1
+    | Lop(Itailcall_ind) -> 5
+    | Lop(Itailcall_imm { func; _ }) -> if func = f.fun_name then 1 else 4
+    | Lop(Iextcall { alloc = true; _ }) -> 3
+    | Lop(Iextcall { alloc = false; _}) -> 1
     | Lop(Istackoffset _) -> 1
     | Lop(Iload(chunk, addr, _mut)) ->
       if chunk = Byte_signed
@@ -500,10 +452,10 @@
       1 + (if lbl0 = None then 0 else 1)
         + (if lbl1 = None then 0 else 1)
         + (if lbl2 = None then 0 else 1)
-    | Lswitch _ -> size 7 (5 + tocload_size()) (5 + tocload_size())
-    | Lentertrap -> size 0 (tocload_size()) (tocload_size())
+    | Lswitch _ -> 7
+    | Lentertrap -> 0
     | Ladjust_trap_depth _ -> 0
-    | Lpushtrap _ -> size 5 (4 + tocload_size()) (4 + tocload_size())
+    | Lpushtrap _ -> 5
     | Lpoptrap -> 2
     | Lraise _ -> 6
 
@@ -580,18 +532,12 @@
       assert (env.f.fun_prologue_required);
       let n = frame_size env in
       if n > 0 then begin
-        `	addi	1, 1, {emit_int(-n)}\n`;
-        cfi_adjust_cfa_offset n
+        `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int(-n)}\n`;
       end;
       if env.f.fun_contains_calls then begin
         let ra = retaddr_offset env in
         `	mflr	0\n`;
         `	{emit_string stg}	0, {emit_int ra}(1)\n`;
-        cfi_offset ~reg: 65 (* LR *) ~offset: (ra - n);
-        match abi with
-        | ELF32 -> ()
-        | ELF64v1 | ELF64v2 ->
-          `	std	2, {emit_int(toc_save_offset env)}(1)\n`
       end
     | Lop(Imove | Ispill | Ireload) ->
         let src = i.arg.(0) and dst = i.res.(0) in
@@ -630,100 +576,37 @@
           `	addis	{emit_reg i.res.(0)}, 0, {emit_int hi}\n`;
           if lo <> 0 then
           `	ori	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, {emit_int lo}\n`
-        end else begin
-          match abi with
-          | ELF32 -> assert false
-          | ELF64v1 | ELF64v2 ->
-              emit_tocload emit_reg i.res.(0) (TocInt n)
         end end end
     | Lop(Iconst_float f) ->
-        begin match abi with
-        | ELF32 ->
-          let lbl = new_label() in
-          env.float_literals <- { fl=f; lbl } :: env.float_literals;
-          `	addis	11, 0, {emit_upper emit_label lbl}\n`;
-          `	lfd	{emit_reg i.res.(0)}, {emit_lower emit_label lbl}(11)\n`
-        | ELF64v1 | ELF64v2 ->
-          let entry = TocFloat f in
-          let lbl = label_for_tocref entry in
-          if !big_toc || !Clflags.for_package <> None then begin
-            `	addis	11, 2, {emit_label lbl}@toc@ha\n`;
-            `	lfd	{emit_reg i.res.(0)}, {emit_label lbl}@toc@l(11) # {emit_tocentry entry}\n`
-          end else begin
-            `	lfd	{emit_reg i.res.(0)}, {emit_label lbl}@toc(2) # {emit_tocentry entry}\n`
-          end
+        begin
+        let lbl = new_label() in
+        env.float_literals <- { fl=f; lbl } :: env.float_literals;
+        `	addis	{emit_gpr 11}, 0, {emit_upper emit_label lbl}\n`;
+        `	lfd	{emit_reg i.res.(0)}, {emit_lower emit_label lbl}({emit_gpr 11})\n`
         end
     | Lop(Iconst_symbol s) ->
-        begin match abi with
-        | ELF32 ->
-          `	addis	{emit_reg i.res.(0)}, 0, {emit_upper emit_symbol s}\n`;
-          `	addi	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, {emit_lower emit_symbol s}\n`
-        | ELF64v1 | ELF64v2 ->
-          emit_tocload emit_reg i.res.(0) (TocSym s)
+        begin
+        `	addis	{emit_reg i.res.(0)}, 0, {emit_upper emit_symbol s}\n`;
+        `	addi	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, {emit_lower emit_symbol s}\n`
         end
     | Lop(Icall_ind) ->
-        begin match abi with
-        | ELF32 ->
-          `	mtctr	{emit_reg i.arg.(0)}\n`;
-          `	bctrl\n`;
-          record_frame env i.live (Dbg_other i.dbg)
-        | ELF64v1 ->
-          `	ld	0, 0({emit_reg i.arg.(0)})\n`;  (* code pointer *)
-          `	mtctr	0\n`;
-          `	ld	2, 8({emit_reg i.arg.(0)})\n`;  (* TOC for callee *)
-          `	bctrl\n`;
-          record_frame env i.live (Dbg_other i.dbg);
-          emit_reload_toc env
-        | ELF64v2 ->
-          `	mtctr	{emit_reg i.arg.(0)}\n`;
-          `	mr	12, {emit_reg i.arg.(0)}\n`;  (* addr of fn in r12 *)
-          `	bctrl\n`;
-          record_frame env i.live (Dbg_other i.dbg);
-          emit_reload_toc env
+        begin
+        `	mtctr	{emit_reg i.arg.(0)}\n`;
+        `	bctrl\n`;
+        record_frame env i.live (Dbg_other i.dbg)
         end
     | Lop(Icall_imm { func; }) ->
-        begin match abi with
-        | ELF32 ->
-            emit_call func;
-            record_frame env i.live (Dbg_other i.dbg)
-        | ELF64v1 | ELF64v2 ->
-        (* For PPC64, we cannot just emit a "bl s; nop" sequence, because
-           of the following scenario:
-              - current function f1 calls f2 that has the same TOC
-              - f2 tailcalls f3 that has a different TOC
-           Because f1 and f2 have the same TOC, the linker inserted no
-           code in f1 to save and restore r2 around the call to f2.
-           Because f2 tailcalls f3, r2 will not be restored to f2's TOC
-           when f3 returns.  So, we're back into f1, with the wrong TOC in r2.
-           We have two options:
-             1- Turn the call into an indirect call, like we do for
-                Itailcall_imm.  Cost: 6 instructions.
-             2- Follow the "bl" with an instruction to restore r2
-                explicitly.  If the called function has a different TOC,
-                this instruction is redundant with those inserted
-                by the linker, but this is harmless.
-                Cost: 3 instructions if same TOC, 7 if different TOC.
-           Let's try option 2. *)
-            emit_call func;
-            record_frame env i.live (Dbg_other i.dbg);
-            `	nop\n`;
-            emit_reload_toc env
+        begin
+        emit_call func;
+        record_frame env i.live (Dbg_other i.dbg)
         end
     | Lop(Itailcall_ind) ->
-        begin match abi with
-        | ELF32 ->
-          `	mtctr	{emit_reg i.arg.(0)}\n`
-        | ELF64v1 ->
-          `	ld	0, 0({emit_reg i.arg.(0)})\n`;  (* code pointer *)
-          `	mtctr	0\n`;
-          `	ld	2, 8({emit_reg i.arg.(0)})\n`   (* TOC for callee *)
-        | ELF64v2 ->
-          `	mtctr	{emit_reg i.arg.(0)}\n`;
-          `	mr	12, {emit_reg i.arg.(0)}\n`   (* addr of fn in r12 *)
+        begin
+        `	mtctr	{emit_reg i.arg.(0)}\n`;
         end;
         if env.f.fun_contains_calls then begin
-          `	{emit_string lg}	11, {emit_int(retaddr_offset env)}(1)\n`;
-          `	mtlr	11\n`
+          `	{emit_string lg}	{emit_gpr 11}, {emit_int(retaddr_offset env)}(1)\n`;
+          `	mtlr	{emit_gpr 11}\n`
         end;
         emit_free_frame env;
         `	bctr\n`
@@ -731,49 +614,39 @@
         if func = env.f.fun_name then
           `	b	{emit_label env.f.fun_tailrec_entry_point_label}\n`
         else begin
-          begin match abi with
-          | ELF32 ->
-            ()
-          | ELF64v1 ->
-            emit_tocload emit_gpr 11 (TocSym func);
-            `	ld	0, 0(11)\n`;  (* code pointer *)
-            `	mtctr	0\n`;
-            `	ld	2, 8(11)\n`   (* TOC for callee *)
-          | ELF64v2 ->
-            emit_tocload emit_gpr 12 (TocSym func); (* addr of fn must be in r12 *)
-            `	mtctr	12\n`
-          end;
           if env.f.fun_contains_calls then begin
-            `	{emit_string lg}	11, {emit_int(retaddr_offset env)}(1)\n`;
-            `	mtlr	11\n`
+            `	{emit_string lg}	{emit_gpr 11}, {emit_int(retaddr_offset env)}(1)\n`;
+            `	mtlr	{emit_gpr 11}\n`
           end;
           emit_free_frame env;
-          begin match abi with
-          | ELF32 ->
-            `	b	{emit_symbol func}\n`
-          | ELF64v1 | ELF64v2 ->
-            `	bctr\n`
+          begin
+          `	b	{emit_symbol func}\n`
           end
         end
     | Lop(Iextcall { func; alloc; }) ->
-        if not alloc then begin
-          emit_call func;
-          emit_call_nop()
+        if alloc then begin
+          if pic_externals then begin
+            external_functions := StringSet.add func !external_functions;
+            `	addis	{emit_gpr 11}, 0, ha16(L{emit_symbol func}$non_lazy_ptr)\n`;
+            `	{emit_string lg}	{emit_gpr 11}, lo16(L{emit_symbol func}$non_lazy_ptr)({emit_gpr 11})\n`
+          end else begin
+            `	addis	{emit_gpr 11}, 0, {emit_upper emit_symbol func}\n`;
+            `	addi	{emit_gpr 11}, {emit_gpr 11}, {emit_lower emit_symbol func}\n`
+          end;
+          `	bl	{emit_symbol "caml_c_call"}\n`;
+          record_frame env i.live (Dbg_other i.dbg)
         end else begin
-          match abi with
-          | ELF32 ->
-            `	addis	25, 0, {emit_upper emit_symbol func}\n`;
-            `	addi	25, 25, {emit_lower emit_symbol func}\n`;
-            emit_call "caml_c_call";
-            record_frame env i.live (Dbg_other i.dbg)
-          | ELF64v1 | ELF64v2 ->
-            emit_tocload emit_gpr 25 (TocSym func);
-            emit_call "caml_c_call";
-            record_frame env i.live (Dbg_other i.dbg);
-            `	nop\n`
+          if pic_externals then begin
+            external_functions := StringSet.add func !external_functions;
+            `	addis	{emit_gpr 11}, 0, ha16(L{emit_symbol func}$non_lazy_ptr)\n`;
+            `	{emit_string lg}	{emit_gpr 11}, lo16(L{emit_symbol func}$non_lazy_ptr)({emit_gpr 11})\n`;
+            `	mtctr	{emit_gpr 11}\n`;
+            `	bctrl\n`
+          end else
+          `	bl	{emit_symbol func}\n`
         end
     | Lop(Istackoffset n) ->
-        `	addi	1, 1, {emit_int (-n)}\n`;
+        `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int (-n)}\n`;
         adjust_stack_offset env n
     | Lop(Iload(chunk, addr, _mut)) ->
         let loadinstr =
@@ -784,7 +657,7 @@
           | Sixteen_signed -> "lha"
           | Thirtytwo_unsigned -> "lwz"
           | Thirtytwo_signed -> if ppc64 then "lwa" else "lwz"
-	  | Word_int | Word_val -> lg
+	    | Word_int | Word_val -> lg
           | Single -> "lfs"
           | Double -> "lfd" in
         emit_load_store loadinstr addr i.arg 0 i.res.(0);
@@ -793,10 +666,10 @@
     | Lop(Istore(chunk, addr, _)) ->
         let storeinstr =
           match chunk with
-          | Byte_unsigned | Byte_signed -> "stb"
+            Byte_unsigned | Byte_signed -> "stb"
           | Sixteen_unsigned | Sixteen_signed -> "sth"
-	  | Thirtytwo_unsigned | Thirtytwo_signed -> "stw"
-	  | Word_int | Word_val -> stg
+	    | Thirtytwo_unsigned | Thirtytwo_signed -> "stw"
+	    | Word_int | Word_val -> stg
           | Single -> "stfs"
           | Double -> "stfd" in
         emit_load_store storeinstr addr i.arg 1 i.arg.(0)
@@ -811,9 +684,9 @@
     | Lop(Iintop Isub) ->               (* subfc has swapped arguments *)
         `	subfc	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}\n`
     | Lop(Iintop Imod) ->
-        `	{emit_string divg}	0, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
-        `	{emit_string mullg}	0, 0, {emit_reg i.arg.(1)}\n`;
-        `	subfc	{emit_reg i.res.(0)}, 0, {emit_reg i.arg.(0)}\n`
+        `	{emit_string divg}	{emit_gpr 0}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
+        `	{emit_string mullg}	{emit_gpr 0}, {emit_gpr 0}, {emit_reg i.arg.(1)}\n`;
+        `	subfc	{emit_reg i.res.(0)}, {emit_gpr 0}, {emit_reg i.arg.(0)}\n`
     | Lop(Iintop(Icomp cmp)) ->
         begin match cmp with
           Isigned c ->
@@ -823,7 +696,7 @@
             `	{emit_string cmplg}	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
             emit_set_comp c i.res.(0)
         end
-    | Lop(Iintop (Icheckbound)) ->
+    | Lop(Iintop Icheckbound) ->
         if !Clflags.debug then
           record_frame env Reg.Set.empty (Dbg_other i.dbg);
         `	{emit_string tglle}   {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
@@ -856,43 +729,35 @@
         `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
     | Lop(Ifloatofint) ->
 	if ppc64 then begin
-          (* Can use protected zone (288 bytes below r1 *)
-	  `	std	{emit_reg i.arg.(0)}, -16(1)\n`;
-          `	lfd	{emit_reg i.res.(0)}, -16(1)\n`;
+	  `	stdu	{emit_reg i.arg.(0)}, -16({emit_gpr 1})\n`;
+          `	lfd	{emit_reg i.res.(0)}, 0({emit_gpr 1})\n`;
+          `	addi	{emit_gpr 1}, {emit_gpr 1}, 16\n`;
           `	fcfid	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}\n`
 	end else begin
           let lbl = new_label() in
-          env.float_literals <- {fl=0x4330000080000000L; lbl} :: env.float_literals;
-          `	addis	11, 0, {emit_upper emit_label lbl}\n`;
-          `	lfd	0, {emit_lower emit_label lbl}(11)\n`;
-          `	lis	0, 0x4330\n`;
-          `	stwu	0, -16(1)\n`;
-          `	xoris	0, {emit_reg i.arg.(0)}, 0x8000\n`;
-          `	stw	0, 4(1)\n`;
-          `	lfd	{emit_reg i.res.(0)}, 0(1)\n`;
-          `	addi	1, 1, 16\n`;
-          `	fsub	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 0\n`
+          float_literals := (0x4330000080000000L, lbl) :: !float_literals;
+          `	addis	{emit_gpr 11}, 0, {emit_upper emit_label lbl}\n`;
+          `	lfd	{emit_fpr 0}, {emit_lower emit_label lbl}({emit_gpr 11})\n`;
+          `	lis	{emit_gpr 0}, 0x4330\n`;
+          `	stwu	{emit_gpr 0}, -16({emit_gpr 1})\n`;
+          `	xoris	{emit_gpr 0}, {emit_reg i.arg.(0)}, 0x8000\n`;
+          `	stw	{emit_gpr 0}, 4({emit_gpr 1})\n`;
+          `	lfd	{emit_reg i.res.(0)}, 0({emit_gpr 1})\n`;
+          `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int trap_size}\n`;
+          `	fsub	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, {emit_fpr 0}\n`
 	end
     | Lop(Iintoffloat) ->
-        if ppc64 then begin
-          (* Can use protected zone (288 bytes below r1 *)
-          `	fctidz	0, {emit_reg i.arg.(0)}\n`;
-          `	stfd	0, -16(1)\n`;
-          `	ld	{emit_reg i.res.(0)}, -16(1)\n`
-        end else begin
-          `	fctiwz	0, {emit_reg i.arg.(0)}\n`;
-          `	stfdu	0, -16(1)\n`;
-          `	lwz	{emit_reg i.res.(0)}, 4(1)\n`;
-          `	addi	1, 1, 16\n`
-        end
-    | Lop(Iopaque) ->
-        assert (i.arg.(0).loc = i.res.(0).loc)
+        let ofs = if ppc64 then 0 else 4 in
+        `	{emit_string fctigz}	{emit_fpr 0}, {emit_reg i.arg.(0)}\n`;
+        `	stfdu	{emit_fpr 0}, -16({emit_gpr 1})\n`;
+        `	{emit_string lg}	{emit_reg i.res.(0)}, {emit_int ofs}({emit_gpr 1})\n`;
+        `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int trap_size}\n`
     | Lop(Ispecific sop) ->
         let instr = name_for_specific sop in
         `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`
     | Lreloadretaddr ->
-        `	{emit_string lg}	11, {emit_int(retaddr_offset env)}(1)\n`;
-        `	mtlr	11\n`
+        `	{emit_string lg}	{emit_gpr 11}, {emit_int(retaddr_offset env)}(1)\n`;
+        `	mtlr	{emit_gpr 11}\n`
     | Lreturn ->
         emit_free_frame env;
         `	blr\n`
@@ -960,33 +825,16 @@
         end
     | Lswitch jumptbl ->
         let lbl = new_label() in
-        if ppc64 then begin
-          let jumptables_lbl = match env.jumptables_lbl with
-            | None ->
-              env.jumptables_lbl <- Some lbl;
-              assert (List.length env.jumptables = 0);
-              lbl
-            | Some l-> l
-          in
-          let start = List.length env.jumptables in
-          let (start_lo, start_hi) = low_high_s start in
-          emit_tocload emit_gpr 11 (TocLabel jumptables_lbl);
-          `	addi	12, {emit_reg i.arg.(0)}, {emit_int start_lo}\n`;
-          if start_hi <> 0 then
-            `	addis	12, 12, {emit_int start_hi}\n`;
-          `	sldi	12, 12, 2\n`
-        end else begin
-          `	addis	11, 0, {emit_upper emit_label lbl}\n`;
-          `	addi	11, 11, {emit_lower emit_label lbl}\n`;
+          begin
+          `	addis	{emit_gpr 0}, 0, {emit_upper emit_label lbl}\n`;
+          `	addi	{emit_gpr 0}, {emit_gpr 0}, {emit_lower emit_label lbl}\n`;
           `	slwi	12, {emit_reg i.arg.(0)}, 2\n`
-        end;
-        `	{emit_string lwa}x	0, 11, 12\n`;
-        `	add	0, 11, 0\n`;
-        `	mtctr	0\n`;
-        `	bctr\n`;
-        if ppc64 then begin
-          env.jumptables <- List.rev_append (Array.to_list jumptbl) env.jumptables
-        end else begin
+          end;
+          `	{emit_string lwa}x	0, 11, 12\n`;
+          `	add	0, {emit_gpr 0}, 0\n`;
+          `	mtctr	0\n`;
+          `	bctr\n`;
+          begin
           emit_string rodata_space;
           `{emit_label lbl}:`;
           for i = 0 to Array.length jumptbl - 1 do
@@ -994,162 +842,102 @@
           done;
           emit_string code_space
         end
-    | Lentertrap ->
-        begin match abi with
-        | ELF32 -> ()
-        | ELF64v1 | ELF64v2 -> emit_reload_toc env
-        end
+    | Lentertrap -> ()
     | Ladjust_trap_depth { delta_traps } ->
         adjust_stack_offset env (trap_size * delta_traps)
     | Lpushtrap { lbl_handler; } ->
-        begin match abi with
-        | ELF32 ->
-          `	addis	11, 0, {emit_upper emit_label lbl_handler}\n`;
-          `	addi	11, 11, {emit_lower emit_label lbl_handler}\n`;
-          `	stwu    11, -16(1)\n`;
-          adjust_stack_offset env 16;
-          `	stw	29, 4(1)\n`;
-          `	mr	29, 1\n`
-        | ELF64v1 | ELF64v2 ->
-          `	addi	1, 1, {emit_int (-trap_size)}\n`;
-          adjust_stack_offset env trap_size;
-          `	std	29, {emit_int trap_previous_offset}(1)\n`;
-          emit_tocload emit_gpr 29 (TocLabel lbl_handler);
-          `	std     29, {emit_int trap_handler_offset}(1)\n`;
-          `	mr	29, 1\n`
-          end
+          `	addis	{emit_gpr 0}, 0, {emit_upper emit_label lbl_handler}\n`;
+          `	addi	{emit_gpr 0}, {emit_gpr 0}, {emit_lower emit_label lbl_handler}\n`;
+        `	{emit_string stg}u	{emit_gpr 0}, -16({emit_gpr 1})\n`;
+        adjust_stack_offset env 16;
+        `	{emit_string stg}	{emit_gpr 29}, {emit_int size_addr}({emit_gpr 1})\n`;
+        `	mr	{emit_gpr 29}, {emit_gpr 1}\n`
     | Lpoptrap ->
-        `	{emit_string lg}	29, {emit_int trap_previous_offset}(1)\n`;
-        `	addi	1, 1, {emit_int trap_size}\n`;
+        `	{emit_string lg}	{emit_gpr 29}, {emit_int size_addr}({emit_gpr 1})\n`;
+        `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int trap_size}\n`;
         adjust_stack_offset env (-trap_size)
     | Lraise k ->
-        begin match k with
-        | Lambda.Raise_regular ->
-            `	li	0, 0\n`;
-            let backtrace_pos =
-              Domainstate.(idx_of_field Domain_backtrace_pos)
-            in
-            begin match abi with
-            | ELF32 -> `	stw	0, {emit_int (backtrace_pos * 8)}(30)\n`
-            | _ -> `	std	0, {emit_int (backtrace_pos * 8)}(30)\n`
-            end;
-            emit_call "caml_raise_exn";
-            record_frame env Reg.Set.empty (Dbg_raise i.dbg);
-            emit_call_nop()
-        | Lambda.Raise_reraise ->
-            emit_call "caml_raise_exn";
-            record_frame env Reg.Set.empty (Dbg_raise i.dbg);
-            emit_call_nop()
-        | Lambda.Raise_notrace ->
-            `	{emit_string lg}	0, {emit_int trap_handler_offset}(29)\n`;
-            `	mr	1, 29\n`;
-            `	mtctr   0\n`;
-            `	{emit_string lg}	29, {emit_int trap_previous_offset}(1)\n`;
-            `	addi	1, 1, {emit_int trap_size}\n`;
-            `	bctr\n`
+        begin match !Clflags.debug, k with
+        | true, Lambda.Raise_regular ->
+          `	bl	{emit_symbol "caml_raise_exn"}\n`;
+          record_frame env Reg.Set.empty (Dbg_raise i.dbg);
+        | true, Lambda.Raise_reraise ->
+          `	bl	{emit_symbol "caml_reraise_exn"}\n`;
+          record_frame env Reg.Set.empty (Dbg_raise i.dbg);
+        | false, _
+        | true, Lambda.Raise_notrace ->
+          `	{emit_string lg}	{emit_gpr 0}, 0({emit_gpr 29})\n`;
+          `	mr	{emit_gpr 1}, {emit_gpr 29}\n`;
+          `	mtctr	{emit_gpr 0}\n`;
+          `	{emit_string lg}	{emit_gpr 29}, {emit_int size_addr}({emit_gpr 1})\n`;
+          `	addi	{emit_gpr 1}, {emit_gpr 1}, {emit_int trap_size}\n`;
+          `	bctr\n`
         end
 
-(* Emit a sequence of instructions *)
-
-let rec emit_all env i =
-  match i.desc with
-  | Lend -> ()
-  |  _   -> emit_instr env i; emit_all env i.next
+let no_interference res arg =
+  try
+    for i = 0 to Array.length arg - 1 do
+      for j = 0 to Array.length res - 1 do
+        if arg.(i).loc = res.(j).loc then raise Exit
+      done
+    done;
+    true
+  with Exit ->
+    false
 
 (* Emission of a function declaration *)
 
 let fundecl fundecl =
   let env = mk_env fundecl in
-  begin match abi with
-  | ELF32 ->
-    emit_string code_space;
-    `	.globl	{emit_symbol fundecl.fun_name}\n`;
-    `	.type	{emit_symbol fundecl.fun_name}, @function\n`;
-    `	.align	2\n`;
-    `{emit_symbol fundecl.fun_name}:\n`
-  | ELF64v1 ->
-    emit_string function_descr_space;
-    `	.align 3\n`;
-    `	.globl	{emit_symbol fundecl.fun_name}\n`;
-    `	.type   {emit_symbol fundecl.fun_name}, @function\n`;
-    `{emit_symbol fundecl.fun_name}:\n`;
-    `	.quad .L.{emit_symbol fundecl.fun_name}, .TOC.@tocbase\n`;
-    emit_string code_space;
-    `	.align  2\n`;
-    `.L.{emit_symbol fundecl.fun_name}:\n`
-  | ELF64v2 ->
-    emit_string code_space;
-    `	.globl	{emit_symbol fundecl.fun_name}\n`;
-    `	.type	{emit_symbol fundecl.fun_name}, @function\n`;
-    `	.align	2\n`;
-    `{emit_symbol fundecl.fun_name}:\n`;
-    `0:	addis	2, 12, (.TOC. - 0b)@ha\n`;
-    `	addi	2, 2, (.TOC. - 0b)@l\n`;
-    `	.localentry {emit_symbol fundecl.fun_name}, . - 0b\n`
+  if Config.system = "rhapsody" && not !Clflags.output_c_object && is_generic_function fundecl.fun_name
+  then (* PR#4690 *)
+    `	.private_extern	{emit_symbol fundecl.fun_name}\n`
+  else
+  `	.globl	{emit_symbol fundecl.fun_name}\n`;
+  begin match Config.system with
+  | "elf" | "bsd" | "bsd_elf" ->
+      `	.type	{emit_symbol fundecl.fun_name}, @function\n`
+  | _ -> ()
   end;
-  emit_debug_info fundecl.fun_dbg;
-  cfi_startproc();
-  (* On this target, there is at most one "out of line" code block per
-     function: a single "call GC" point.  It comes immediately after the
-     function's body. *)
-  BR.relax fundecl ~max_out_of_line_code_offset:0;
-  emit_all env fundecl.fun_body;
+  emit_string code_space;
+  `	.align	2\n`;
+  `{emit_symbol fundecl.fun_name}:\n`;
+    if env.f.fun_contains_calls then begin
+    `	mflr	{emit_gpr 0}\n`;
+    `	{emit_string lg}	{emit_gpr 11}, {emit_int(retaddr_offset env)}(1)\n`;
+        end;
+        emit_free_frame env;
   (* Emit the glue code to call the GC *)
-  if env.call_gc_label > 0 then begin
-    `{emit_label env.call_gc_label}:\n`;
-    match abi with
-    | ELF32 ->
-      `	b	{emit_symbol "caml_call_gc"}\n`
-    | ELF64v1 ->
-      `	std	2, 40(1)\n`;
-             (* save our TOC, will be restored by caml_call_gc *)
-      emit_tocload emit_gpr 11 (TocSym "caml_call_gc");
-      `	ld	0, 0(11)\n`;
-      `	mtctr	0\n`;
-      `	ld	2, 8(11)\n`;
-      `	bctr\n`
-    | ELF64v2 ->
-      `	std	2, 24(1)\n`;
-             (* save our TOC, will be restored by caml_call_gc *)
-      emit_tocload emit_gpr 12 (TocSym "caml_call_gc");
-      `	mtctr	12\n`;
-      `	bctr\n`
-  end;
-  cfi_endproc();
-  begin match abi with
-  | ELF32 | ELF64v2 ->
-    `	.size	{emit_symbol fundecl.fun_name}, . - {emit_symbol fundecl.fun_name}\n`
-  | ELF64v1 ->
-    `	.size	{emit_symbol fundecl.fun_name}, . - .L.{emit_symbol fundecl.fun_name}\n`
+  if !call_gc_label > 0 then begin
+    `{emit_label !call_gc_label}:\n`;
+    `	b	{emit_symbol "caml_call_gc"}\n`
   end;
   (* Emit the numeric literals *)
-  if env.float_literals <> [] then begin
+  if !float_literals <> [] || !int_literals <> [] then begin
     emit_string rodata_space;
     `	.align	3\n`;
     List.iter
-      (fun { fl; lbl } ->
+      (fun (f, lbl) ->
         `{emit_label lbl}:`;
-        emit_float64_split_directive ".long" fl)
-      env.float_literals
-  end;
-  (* Emit the jump tables *)
-  match env.jumptables, env.jumptables_lbl with
-  | _ :: _, None | [], Some _ -> assert false (* Sanity check *)
-  | [], None -> ()
-  | _ :: _, Some j ->
-    emit_string rodata_space;
-    `	.align	2\n`;
-    `{emit_label j}:`;
+        if ppc64
+        then emit_float64_directive ".quad" f
+        else emit_float64_split_directive ".long" f)
+      !float_literals;
     List.iter
-      (fun  lbl ->
-         `	.long	{emit_label lbl} - {emit_label j}\n`)
-      (List.rev env.jumptables)
+      (fun (n, lbl) ->
+        `{emit_label lbl}:	{emit_string datag}	{emit_nativeint n}\n`)
+      !int_literals
+  end
 
 (* Emission of data *)
 
 let declare_global_data s =
   `	.globl	{emit_symbol s}\n`;
-  `	.type	{emit_symbol s}, @object\n`
+  match Config.system with
+  | "elf" | "bsd" | "bsd_elf" ->
+    `	.type	{emit_symbol s}, @object\n`
+  | "rhapsody" -> ()
+  | _ -> assert false
 
 let emit_item = function
     Cglobal_symbol s ->
@@ -1181,53 +969,40 @@
 
 let data l =
   emit_string data_space;
-  `	.align  {emit_int (if ppc64 then 3 else 2)}\n`;
   List.iter emit_item l
 
 (* Beginning / end of an assembly file *)
 
 let begin_assembly() =
-  reset_debug_info();
-  `	.file	\"\"\n`;  (* PR#7037 *)
-  begin match abi with
-  | ELF64v2 -> `	.abiversion 2\n`
-  | _ -> ()
-  end;
-  Hashtbl.clear tocref_entries;
+  defined_functions := StringSet.empty;
+  external_functions := StringSet.empty;
   (* Emit the beginning of the segments *)
   let lbl_begin = Compilenv.make_symbol (Some "data_begin") in
   emit_string data_space;
   declare_global_data lbl_begin;
   `{emit_symbol lbl_begin}:\n`;
   let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
-  emit_string function_descr_space;
-  (* For the ELF64v1 ABI, we must make sure that the .opd and .data
-     sections are in different pages.  .opd comes after .data,
-     so aligning .opd is enough.  To save space, we do it only
-     for the startup file, not for every OCaml compilation unit. *)
-  let c = Compilenv.current_unit_name() in
-  if abi = ELF64v1 && (c = "_startup" || c = "_shared_startup") then begin
-    `	.p2align	12\n`
-  end;
+  emit_string code_space;
   declare_global_data lbl_begin;
   `{emit_symbol lbl_begin}:\n`
 
 let end_assembly() =
+  if pic_externals then
+    (* Emit the pointers to external functions *)
+    StringSet.iter emit_external !external_functions;
   (* Emit the end of the segments *)
-  emit_string function_descr_space;
+  emit_string code_space;
   let lbl_end = Compilenv.make_symbol (Some "code_end") in
   declare_global_data lbl_end;
   `{emit_symbol lbl_end}:\n`;
-  if abi <> ELF64v1 then `	.long	0\n`;
+  `	.long	0\n`;
   emit_string data_space;
   let lbl_end = Compilenv.make_symbol (Some "data_end") in
   declare_global_data lbl_end;
-  `	{emit_string datag}	0\n`;  (* PR#6329 *)
   `{emit_symbol lbl_end}:\n`;
   `	{emit_string datag}	0\n`;
   (* Emit the frame descriptors *)
-  emit_string data_space;  (* not rodata_space because it contains relocations *)
-  if ppc64 then `	.align  3\n`;   (* #7887 *)
+  emit_string rodata_space;
   let lbl = Compilenv.make_symbol (Some "frametable") in
   declare_global_data lbl;
   `{emit_symbol lbl}:\n`;
@@ -1240,18 +1015,9 @@
       efa_16 = (fun n -> `	.short	{emit_int n}\n`);
       efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
       efa_word = (fun n -> `	{emit_string datag}	{emit_int n}\n`);
-      efa_align = (fun n -> `	.balign	{emit_int n}\n`);
+      efa_align = (fun n -> `	.align	{emit_int (Misc.log2 n)}\n`);
       efa_label_rel = (fun lbl ofs ->
                            `	.long	({emit_label lbl} - .) + {emit_int32 ofs}\n`);
       efa_def_label = (fun l -> `{emit_label l}:\n`);
       efa_string = (fun s -> emit_bytes_directive "	.byte	" (s ^ "\000"))
-     };
-  (* Emit the TOC entries *)
-  begin match abi with
-  | ELF32 -> ()
-  | ELF64v1 | ELF64v2 ->
-      emit_string toc_space;
-      emit_toctable();
-      Hashtbl.clear tocref_entries
-  end;
-  `	.section .note.GNU-stack,\"\",%progbits\n`
+     }

