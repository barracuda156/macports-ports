From 776c652ca26dd6bb710b551c886ca6e4122b358b Mon Sep 17 00:00:00 2001
From: barracuda156 <vital.had@gmail.com>
Date: Wed, 19 Jul 2023 19:57:34 +0800
Subject: [PATCH 5/5] SDL_cocoamodes: use some legacy code

---
 src/video/cocoa/SDL_cocoaclipboard.m |   2 +
 src/video/cocoa/SDL_cocoaevents.m    |  13 +-
 src/video/cocoa/SDL_cocoakeyboard.m  |  17 +-
 src/video/cocoa/SDL_cocoamodes.m     | 313 ++++++++++-----------------
 4 files changed, 145 insertions(+), 200 deletions(-)

diff --git src/video/cocoa/SDL_cocoaclipboard.m src/video/cocoa/SDL_cocoaclipboard.m
index 9d5e95808..14acb3613 100644
--- src/video/cocoa/SDL_cocoaclipboard.m
+++ src/video/cocoa/SDL_cocoaclipboard.m
@@ -22,6 +22,8 @@
 
 #if SDL_VIDEO_DRIVER_COCOA
 
+#include <AvailabilityMacros.h>
+
 #include "SDL_cocoavideo.h"
 #include "../../events/SDL_clipboardevents_c.h"
 
diff --git src/video/cocoa/SDL_cocoaevents.m src/video/cocoa/SDL_cocoaevents.m
index d60b5a7c9..e9fc87a67 100644
--- src/video/cocoa/SDL_cocoaevents.m
+++ src/video/cocoa/SDL_cocoaevents.m
@@ -261,11 +261,14 @@ static void Cocoa_DispatchEvent(NSEvent *theEvent)
      * the active Space in z-order (including the 'About' window, if it's shown)
      * and make the first one key.
      */
-    for (NSNumber *num in [NSWindow windowNumbersWithOptions:0]) {
-        NSWindow *window = [NSApp windowWithWindowNumber:[num integerValue]];
-        if (window && window != win && [window canBecomeKeyWindow]) {
-            [window makeKeyAndOrderFront:self];
-            return;
+    if ([NSWindow respondsToSelector:@selector(windowNumbersWithOptions:)]) {
+        /* Get all visible windows in the active Space, in z-order. */
+        for (NSNumber *num in [NSWindow windowNumbersWithOptions:0]) {
+            NSWindow *window = [NSApp windowWithWindowNumber:[num integerValue]];
+            if (window && window != win && [window canBecomeKeyWindow]) {
+                [window makeKeyAndOrderFront:self];
+                return;
+            }
         }
     }
 }
diff --git src/video/cocoa/SDL_cocoakeyboard.m src/video/cocoa/SDL_cocoakeyboard.m
index bf0992c1a..f465d9ab7 100644
--- src/video/cocoa/SDL_cocoakeyboard.m
+++ src/video/cocoa/SDL_cocoakeyboard.m
@@ -69,6 +69,14 @@
     SDL_SendKeyboardText(str);
 }
 
+- (void)insertText:(id)insertString
+{
+    /* This method is part of NSTextInput and not NSTextInputClient, but
+     * apparently it still might be called in OS X 10.5 and can cause beeps if
+     * the implementation is missing: http://crbug.com/47890 */
+    [self insertText:insertString replacementRange:NSMakeRange(0, 0)];
+}
+
 - (void)doCommandBySelector:(SEL)myselector
 {
     /* No need to do anything since we are not using Cocoa
@@ -479,8 +487,13 @@ Cocoa_InitKeyboard(_THIS)
     SDL_SetScancodeName(SDL_SCANCODE_RALT, "Right Option");
     SDL_SetScancodeName(SDL_SCANCODE_RGUI, "Right Command");
 
-    data->modifierFlags = (unsigned int)[NSEvent modifierFlags];
-    SDL_ToggleModState(KMOD_CAPS, (data->modifierFlags & NSEventModifierFlagCapsLock) != 0);
+    /* On pre-10.6, you might have the initial capslock key state wrong. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
+    if (floor(NSAppKitVersionNumber) >= NSAppKitVersionNumber10_6) {
+        data->modifierFlags = [NSEvent modifierFlags];
+        SDL_ToggleModState(KMOD_CAPS, (data->modifierFlags & NSAlphaShiftKeyMask) != 0);
+    }
+#endif
 }
 
 void
diff --git src/video/cocoa/SDL_cocoamodes.m src/video/cocoa/SDL_cocoamodes.m
index 4d509fd1a..5e041e155 100644
--- src/video/cocoa/SDL_cocoamodes.m
+++ src/video/cocoa/SDL_cocoamodes.m
@@ -24,28 +24,19 @@
 
 #include "SDL_cocoavideo.h"
 
-/* This gets us MAC_OS_X_VERSION_MIN_REQUIRED... */
-#include <AvailabilityMacros.h>
-
 /* We need this for IODisplayCreateInfoDictionary and kIODisplayOnlyPreferredName */
 #include <IOKit/graphics/IOGraphicsLib.h>
 
 /* We need this for CVDisplayLinkGetNominalOutputVideoRefreshPeriod */
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
 #include <CoreVideo/CVBase.h>
 #include <CoreVideo/CVDisplayLink.h>
 
-#ifndef MAC_OS_X_VERSION_10_13
-#define NSAppKitVersionNumber10_12 1504
-#endif
-#if (IOGRAPHICSTYPES_REV < 40)
-#define kDisplayModeNativeFlag 0x02000000
-#endif
-#endif
-
 /* we need this for ShowMenuBar() and HideMenuBar(). */
 #include <Carbon/Carbon.h>
 
+/* This gets us MAC_OS_X_VERSION_MIN_REQUIRED... */
+#include <AvailabilityMacros.h>
+
 
 static void
 Cocoa_ToggleMenuBar(const BOOL show)
@@ -64,6 +55,23 @@ Cocoa_ToggleMenuBar(const BOOL show)
 #endif
 }
 
+#define FORCE_OLD_API 1
+
+#if FORCE_OLD_API
+#undef MAC_OS_X_VERSION_MIN_REQUIRED
+#define MAC_OS_X_VERSION_MIN_REQUIRED 1050
+#endif
+
+static BOOL
+IS_SNOW_LEOPARD_OR_LATER()
+{
+#if FORCE_OLD_API
+    return NO;
+#else
+    return floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_5;
+#endif
+}
+
 static int
 CG_SetError(const char *prefix, CGDisplayErr result)
 {
@@ -128,7 +136,7 @@ GetDisplayModeRefreshRate(const void *moderef, CVDisplayLinkRef link)
 }
 
 static SDL_bool
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
+
 HasValidDisplayModeFlags(CGDisplayModeRef vidmode)
 #else
 HasValidDisplayModeFlags(const void *moderef)
@@ -152,9 +160,6 @@ HasValidDisplayModeFlags(const void *moderef)
 static Uint32
 #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
 GetDisplayModePixelFormat(CGDisplayModeRef vidmode)
-#else
-GetDisplayModePixelFormat(const void *moderef)
-#endif
 {
     /* This API is deprecated in 10.11 with no good replacement (as of 10.15). */
     CFStringRef fmt = CGDisplayModeCopyPixelEncoding(vidmode);
@@ -177,6 +182,25 @@ GetDisplayModePixelFormat(const void *moderef)
 
     return pixelformat;
 }
+#else
+GetDisplayModePixelFormat(const void *moderef)
+    mode->format = SDL_PIXELFORMAT_UNKNOWN;
+    switch (bpp) {
+    case 16:
+        mode->format = SDL_PIXELFORMAT_ARGB1555;
+        break;
+    case 30:
+        mode->format = SDL_PIXELFORMAT_ARGB2101010;
+        break;
+    case 32:
+        mode->format = SDL_PIXELFORMAT_ARGB8888;
+        break;
+    case 8: /* We don't support palettized modes now */
+    default: /* Totally unrecognizable bit depth. */
+        SDL_free(data);
+        return SDL_FALSE;
+    }
+#endif
 
 static SDL_bool
 #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
@@ -191,32 +215,27 @@ GetDisplayMode(_THIS, const void *moderef, CVDisplayLinkRef link, SDL_DisplayMod
     int width = (int) CGDisplayModeGetWidth(vidmode);
     int height = (int) CGDisplayModeGetHeight(vidmode);
     uint32_t ioflags = CGDisplayModeGetIOFlags(vidmode);
-    int refreshrate = GetDisplayModeRefreshRate(vidmode, link);
+    int refreshRate = GetDisplayModeRefreshRate(vidmode, link);
     Uint32 format = GetDisplayModePixelFormat(vidmode);
     bool interlaced = (ioflags & kDisplayModeInterlacedFlag) != 0;
     CFMutableArrayRef modes;
+
+    if (format == SDL_PIXELFORMAT_UNKNOWN) {
+        return SDL_FALSE;
+    }
 #else
     long width = 0;
     long height = 0;
     long bpp = 0;
     long refreshRate = 0;
-#endif
 
-    if (format == SDL_PIXELFORMAT_UNKNOWN) {
-        return SDL_FALSE;
-    }
-
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
-    /* Don't fail the current mode based on flags because this could prevent Cocoa_InitModes from
-     * succeeding if the current mode lacks certain flags (esp kDisplayModeSafeFlag). */
-    if (!vidmodeCurrent && !HasValidDisplayModeFlags(vidmode)) {
+    data = (SDL_DisplayModeData *) SDL_malloc(sizeof(*data));
+    if (!data) {
         return SDL_FALSE;
     }
+    data->moderef = moderef;
 
-    modes = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);
-    CFArrayAppendValue(modes, vidmode);
-#else
-    {
+    if (!IS_SNOW_LEOPARD_OR_LATER()) {
         CFNumberRef number;
         double refresh;
         CFDictionaryRef vidmode = (CFDictionaryRef) moderef;
@@ -232,100 +251,15 @@ GetDisplayMode(_THIS, const void *moderef, CVDisplayLinkRef link, SDL_DisplayMod
     }
 #endif
 
-    /* If a list of possible diplay modes is passed in, use it to filter out
-     * modes that have duplicate sizes. We don't just rely on SDL's higher level
-     * duplicate filtering because this code can choose what properties are
-     * prefered, and it can add CGDisplayModes to the DisplayModeData's list of
-     * modes to try (see comment below for why that's necessary).
-     * CGDisplayModeGetPixelWidth and friends are only available in 10.8+. */
-#ifdef MAC_OS_X_VERSION_10_8
-    if (modelist != NULL && floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_7) {
-        int pixelW = (int) CGDisplayModeGetPixelWidth(vidmode);
-        int pixelH = (int) CGDisplayModeGetPixelHeight(vidmode);
-
-        CFIndex modescount = CFArrayGetCount(modelist);
-        int  i;
-
-        for (i = 0; i < modescount; i++) {
-            CGDisplayModeRef othermode = (CGDisplayModeRef) CFArrayGetValueAtIndex(modelist, i);
-            uint32_t otherioflags = CGDisplayModeGetIOFlags(othermode);
-
-            if (CFEqual(vidmode, othermode)) {
-                continue;
-            }
-
-            if (!HasValidDisplayModeFlags(othermode)) {
-                continue;
-            }
-
-            int otherW = (int) CGDisplayModeGetWidth(othermode);
-            int otherH = (int) CGDisplayModeGetHeight(othermode);
-            int otherpixelW = (int) CGDisplayModeGetPixelWidth(othermode);
-            int otherpixelH = (int) CGDisplayModeGetPixelHeight(othermode);
-            int otherrefresh = GetDisplayModeRefreshRate(othermode, link);
-            Uint32 otherformat = GetDisplayModePixelFormat(othermode);
-            bool otherGUI = CGDisplayModeIsUsableForDesktopGUI(othermode);
-
-            /* Ignore this mode if it's low-dpi (@1x) and we have a high-dpi
-             * mode in the list with the same size in points.
-             */
-            if (width == pixelW && height == pixelH
-                && width == otherW && height == otherH
-                && refreshrate == otherrefresh && format == otherformat
-                && (otherpixelW != otherW || otherpixelH != otherH)) {
-                CFRelease(modes);
-                return SDL_FALSE;
-            }
-
-            /* Ignore this mode if it's interlaced and there's a non-interlaced
-             * mode in the list with the same properties.
-             */
-            if (interlaced && ((otherioflags & kDisplayModeInterlacedFlag) == 0)
-                && width == otherW && height == otherH && pixelW == otherpixelW
-                && pixelH == otherpixelH && refreshrate == otherrefresh
-                && format == otherformat && usableForGUI == otherGUI) {
-                CFRelease(modes);
-                return SDL_FALSE;
-            }
-
-            /* Ignore this mode if it's not usable for desktop UI and its
-             * properties are equal to another GUI-capable mode in the list.
-             */
-            if (width == otherW && height == otherH && pixelW == otherpixelW
-                && pixelH == otherpixelH && !usableForGUI && otherGUI
-                && refreshrate == otherrefresh && format == otherformat) {
-                CFRelease(modes);
-                return SDL_FALSE;
-            }
-
-            /* If multiple modes have the exact same properties, they'll all
-             * go in the list of modes to try when SetDisplayMode is called.
-             * This is needed because kCGDisplayShowDuplicateLowResolutionModes
-             * (which is used to expose highdpi display modes) can make the
-             * list of modes contain duplicates (according to their properties
-             * obtained via public APIs) which don't work with SetDisplayMode.
-             * Those duplicate non-functional modes *do* have different pixel
-             * formats according to their internal data structure viewed with
-             * NSLog, but currently no public API can detect that.
-             * https://bugzilla.libsdl.org/show_bug.cgi?id=4822
-             *
-             * As of macOS 10.15.0, those duplicates have the exact same
-             * properties via public APIs in every way (even their IO flags and
-             * CGDisplayModeGetIODisplayModeID is the same), so we could test
-             * those for equality here too, but I'm intentionally not doing that
-             * in case there are duplicate modes with different IO flags or IO
-             * display mode IDs in the future. In that case I think it's better
-             * to try them all in SetDisplayMode than to risk one of them being
-             * correct but it being filtered out by SDL_AddDisplayMode as being
-             * a duplicate.
-             */
-            if (width == otherW && height == otherH && pixelW == otherpixelW
-                && pixelH == otherpixelH && usableForGUI == otherGUI
-                && refreshrate == otherrefresh && format == otherformat) {
-                CFArrayAppendValue(modes, othermode);
-            }
-        }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
+    /* Don't fail the current mode based on flags because this could prevent Cocoa_InitModes from
+     * succeeding if the current mode lacks certain flags (esp kDisplayModeSafeFlag). */
+    if (!vidmodeCurrent && !HasValidDisplayModeFlags(vidmode)) {
+        return SDL_FALSE;
     }
+
+    modes = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);
+    CFArrayAppendValue(modes, vidmode);
 #endif
 
     data = (SDL_DisplayModeData *) SDL_malloc(sizeof(*data));
@@ -338,21 +272,39 @@ GetDisplayMode(_THIS, const void *moderef, CVDisplayLinkRef link, SDL_DisplayMod
 #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
     data->modes = modes;
     mode->format = format;
+#endif
     mode->w = width;
     mode->h = height;
-    mode->refresh_rate = refreshrate;
+    mode->refresh_rate = refreshRate;
     mode->driverdata = data;
-#else
     data->moderef = moderef;
-#endif
     return SDL_TRUE;
 }
 
+static void
+Cocoa_ReleaseDisplayMode(_THIS, const void *moderef)
+{
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
+    if (IS_SNOW_LEOPARD_OR_LATER()) {
+        CGDisplayModeRelease((CGDisplayModeRef) moderef);  /* NULL is ok */
+    }
+}
+
+static void
+Cocoa_ReleaseDisplayModeList(_THIS, CFArrayRef modelist)
+{
+    if (IS_SNOW_LEOPARD_OR_LATER()) {
+        CFRelease(modelist);  /* NULL is ok */
+    }
+}
+
 static const char *
 Cocoa_GetDisplayName(CGDirectDisplayID displayID)
 {
     /* This API is deprecated in 10.9 with no good replacement (as of 10.15). */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
     io_service_t servicePort = CGDisplayIOServicePort(displayID);
+#endif
     CFDictionaryRef deviceInfo = IODisplayCreateInfoDictionary(servicePort, kIODisplayOnlyPreferredName);
     NSDictionary *localizedNames = [(NSDictionary *)deviceInfo objectForKey:[NSString stringWithUTF8String:kDisplayProductName]];
     const char* displayName = NULL;
@@ -417,9 +369,13 @@ Cocoa_InitModes(_THIS)
             }
 
 #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
-            moderef = CGDisplayCopyDisplayMode(displays[i]);
+            if (IS_SNOW_LEOPARD_OR_LATER()) {
+                moderef = CGDisplayCopyDisplayMode(displays[i]);
+            }
 #else
-            moderef = CGDisplayCurrentMode(displays[i]);
+            if (!IS_SNOW_LEOPARD_OR_LATER()) {
+                moderef = CGDisplayCurrentMode(displays[i]);
+            }
 #endif
 
             if (!moderef) {
@@ -428,9 +384,7 @@ Cocoa_InitModes(_THIS)
 
             displaydata = (SDL_DisplayData *) SDL_malloc(sizeof(*displaydata));
             if (!displaydata) {
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
-                CGDisplayModeRelease(moderef);
-#endif
+                Cocoa_ReleaseDisplayMode(_this, moderef);
                 continue;
             }
             displaydata->display = displays[i];
@@ -447,6 +401,7 @@ Cocoa_InitModes(_THIS)
 #else
             if (!GetDisplayMode(_this, moderef, link, &mode)) {
                 CVDisplayLinkRelease(link);
+                Cocoa_ReleaseDisplayMode(_this, moderef);
 #endif
                 SDL_free(display.name);
                 SDL_free(displaydata);
@@ -454,7 +409,9 @@ Cocoa_InitModes(_THIS)
             }
 
             CVDisplayLinkRelease(link);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
             CGDisplayModeRelease(moderef);
+#endif
 
             display.desktop_mode = mode;
             display.current_mode = mode;
@@ -515,12 +472,12 @@ Cocoa_GetDisplayUsableBounds(_THIS, SDL_VideoDisplay * display, SDL_Rect * rect)
 int
 Cocoa_GetDisplayDPI(_THIS, SDL_VideoDisplay * display, float * ddpi, float * hdpi, float * vdpi)
 {
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
     const float MM_IN_INCH = 25.4f;
 
     SDL_DisplayData *data = (SDL_DisplayData *) display->driverdata;
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     /* we need the backingScaleFactor for Retina displays, which is only exposed through NSScreen, not CGDisplay, afaik, so find our screen... */
     CGFloat scaleFactor = 1.0f;
     NSArray *screens = [NSScreen screens];
@@ -531,39 +488,6 @@ Cocoa_GetDisplayDPI(_THIS, SDL_VideoDisplay * display, float * ddpi, float * hdp
     for (NSScreen *screen in screens) {
         const CGDirectDisplayID dpyid = (const CGDirectDisplayID ) [[[screen deviceDescription] objectForKey:@"NSScreenNumber"] unsignedIntValue];
         if (dpyid == data->display) {
-#ifdef MAC_OS_X_VERSION_10_8
-            /* Neither CGDisplayScreenSize(description's NSScreenNumber) nor [NSScreen backingScaleFactor] can calculate the correct dpi in macOS. E.g. backingScaleFactor is always 2 in all display modes for rMBP 16" */
-            if (floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_7) {
-                CFStringRef dmKeys[1] = { kCGDisplayShowDuplicateLowResolutionModes };
-                CFBooleanRef dmValues[1] = { kCFBooleanTrue };
-                CFDictionaryRef dmOptions = CFDictionaryCreate(kCFAllocatorDefault, (const void**) dmKeys, (const void**) dmValues, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks );
-                CFArrayRef allDisplayModes = CGDisplayCopyAllDisplayModes(dpyid, dmOptions);
-                CFIndex n = CFArrayGetCount(allDisplayModes);
-                for(CFIndex i = 0; i < n; ++i) {
-                    CGDisplayModeRef m = (CGDisplayModeRef)CFArrayGetValueAtIndex(allDisplayModes, i);
-                    CGFloat width = CGDisplayModeGetPixelWidth(m);
-                    CGFloat height = CGDisplayModeGetPixelHeight(m);
-                    CGFloat HiDPIWidth = CGDisplayModeGetWidth(m);
-                    
-                    //Only check 1x mode
-                    if(width == HiDPIWidth) {
-                        if (CGDisplayModeGetIOFlags(m) & kDisplayModeNativeFlag) {
-                            displayNativeSize.width = width;
-                            displayNativeSize.height = height;
-                            break;
-                        }
-                        
-                        //Get the largest size even if kDisplayModeNativeFlag is not present e.g. iMac 27-Inch with 5K Retina
-                        if(width > displayNativeSize.width) {
-                            displayNativeSize.width = width;
-                            displayNativeSize.height = height;
-                        }
-                    }
-                }
-                CFRelease(allDisplayModes);
-                CFRelease(dmOptions);
-            } else
-#endif
             if (floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6) {
                 // fallback for 10.7
                 scaleFactor = [screen backingScaleFactor];
@@ -578,6 +502,20 @@ Cocoa_GetDisplayDPI(_THIS, SDL_VideoDisplay * display, float * ddpi, float * hdp
     const int pixelWidth =  displayNativeSize.width;
     const int pixelHeight = displayNativeSize.height;
 
+    if (ddpi) {
+        *ddpi = (SDL_ComputeDiagonalDPI(pixelWidth, pixelHeight, displaySize.width / MM_IN_INCH, displaySize.height / MM_IN_INCH)) * scaleFactor;
+    }
+    if (hdpi) {
+        *hdpi = (pixelWidth * MM_IN_INCH / displaySize.width) * scaleFactor;
+    }
+    if (vdpi) {
+        *vdpi = (pixelHeight * MM_IN_INCH / displaySize.height) * scaleFactor;
+    }
+#else
+    CGSize displaySize = CGDisplayScreenSize(data->display);
+    int pixelWidth =  (int) CGDisplayPixelsWide(data->display);
+    int pixelHeight = (int) CGDisplayPixelsHigh(data->display);
+
     if (ddpi) {
         *ddpi = (SDL_ComputeDiagonalDPI(pixelWidth, pixelHeight, displaySize.width / MM_IN_INCH, displaySize.height / MM_IN_INCH));
     }
@@ -587,10 +525,9 @@ Cocoa_GetDisplayDPI(_THIS, SDL_VideoDisplay * display, float * ddpi, float * hdp
     if (vdpi) {
         *vdpi = (pixelHeight * MM_IN_INCH / displaySize.height);
     }
-
+#endif
     [pool release];
     return 0;
-#endif
 }
 
 void
@@ -626,41 +563,22 @@ Cocoa_GetDisplayModes(_THIS, SDL_VideoDisplay * display)
     CGDisplayModeRelease(desktopmoderef);
 #endif
 
-    /* By default, CGDisplayCopyAllDisplayModes will only get a subset of the
-     * system's available modes. For example on a 15" 2016 MBP, users can
-     * choose 1920x1080@2x in System Preferences but it won't show up here,
-     * unless we specify the option below.
-     * The display modes returned by CGDisplayCopyAllDisplayModes are also not
-     * high dpi-capable unless this option is set.
-     * macOS 10.15 also seems to have a bug where entering, exiting, and
-     * re-entering exclusive fullscreen with a low dpi display mode can cause
-     * the content of the screen to move up, which this setting avoids:
-     * https://bugzilla.libsdl.org/show_bug.cgi?id=4822
-     */
-#ifdef MAC_OS_X_VERSION_10_8
-    if (floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_7) {
-        const CFStringRef dictkeys[] = {kCGDisplayShowDuplicateLowResolutionModes};
-        const CFBooleanRef dictvalues[] = {kCFBooleanTrue};
-        dict = CFDictionaryCreate(NULL,
-                                  (const void **)dictkeys,
-                                  (const void **)dictvalues,
-                                  1,
-                                  &kCFCopyStringDictionaryKeyCallBacks,
-                                  &kCFTypeDictionaryValueCallBacks);
-    }
-#endif
-
 #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
-    modes = CGDisplayCopyAllDisplayModes(data->display, dict);
+    if (IS_SNOW_LEOPARD_OR_LATER()) {
+        modes = CGDisplayCopyAllDisplayModes(data->display, NULL);
+    }
 
     if (dict) {
         CFRelease(dict);
     }
 #else
-    modes = CGDisplayAvailableModes(data->display);
+    if (!IS_SNOW_LEOPARD_OR_LATER()) {
+        modes = CGDisplayAvailableModes(data->display);
+    }
 #endif
 
     if (modes) {
+        CVDisplayLinkRef link = NULL;
         const CFIndex count = CFArrayGetCount(modes);
         CFIndex i;
 
@@ -689,6 +607,7 @@ Cocoa_GetDisplayModes(_THIS, SDL_VideoDisplay * display)
     }
 
     CVDisplayLinkRelease(link);
+    Cocoa_ReleaseDisplayModeList(_this, modes);
 }
 
 static CGError
@@ -805,11 +724,19 @@ Cocoa_QuitModes(_THIS)
         }
 
         mode = (SDL_DisplayModeData *) display->desktop_mode.driverdata;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
         CFRelease(mode->modes);
+#else
+        Cocoa_ReleaseDisplayMode(_this, mode->moderef);
+#endif
 
         for (j = 0; j < display->num_display_modes; j++) {
             mode = (SDL_DisplayModeData*) display->display_modes[j].driverdata;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined(__ppc__)
             CFRelease(mode->modes);
+#else
+            Cocoa_ReleaseDisplayMode(_this, mode->moderef);
+#endif
         }
     }
     Cocoa_ToggleMenuBar(YES);
-- 
2.41.0

