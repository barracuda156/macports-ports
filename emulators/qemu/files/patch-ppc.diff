--- common-user/host/ppc/safe-syscall.inc.S.orig	2022-04-20 03:10:27.000000000 +0800
+++ common-user/host/ppc/safe-syscall.inc.S	2022-05-31 13:23:21.000000000 +0800
@@ -13,7 +13,6 @@
         .global safe_syscall_base
         .global safe_syscall_start
         .global safe_syscall_end
-        .type   safe_syscall_base, @function
 
         .text
 
@@ -23,19 +22,10 @@
          * second one the system call number (as a 'long'), and all further
          * arguments being syscall arguments (also 'long').
          */
-#if _CALL_ELF == 2
-safe_syscall_base:
-        .cfi_startproc
-        .localentry safe_syscall_base,0
-#else
-        .section ".opd","aw"
+
         .align  3
 safe_syscall_base:
-        .quad   .L.safe_syscall_base,.TOC.@tocbase,0
-        .previous
-.L.safe_syscall_base:
-        .cfi_startproc
-#endif
+
         /* We enter with r3 == &signal_pending
          *               r4 == syscall number
          *               r5 ... r10 == syscall arguments
@@ -46,16 +36,15 @@
          *               and returns the result in r3
          * Shuffle everything around appropriately.
          */
-        std     14, 16(1) /* Preserve r14 in SP+16 */
-        .cfi_offset 14, 16
-        mr      14, 3   /* signal_pending */
-        mr      0, 4    /* syscall number */
-        mr      3, 5    /* syscall arguments */
-        mr      4, 6
-        mr      5, 7
-        mr      6, 8
-        mr      7, 9
-        mr      8, 10
+        stw     r14, 16(r1) /* Preserve r14 in SP+16 */
+        mr      r14, r3   /* signal_pending */
+        mr      r0, r4    /* syscall number */
+        mr      r3, r5    /* syscall arguments */
+        mr      r4, r6
+        mr      r5, r7
+        mr      r6, r8
+        mr      r7, r9
+        mr      r8, r10
 
         /* This next sequence of code works in conjunction with the
          * rewind_if_safe_syscall_function(). If a signal is taken
@@ -66,29 +55,20 @@
          */
 safe_syscall_start:
         /* if signal_pending is non-zero, don't do the call */
-        lwz     12, 0(14)
-        cmpwi   0, 12, 0
+        lwz     r12, 0(r14)
+        cmpwi   cr0, r12, 0
         bne-    2f
         sc
 safe_syscall_end:
         /* code path when we did execute the syscall */
-        ld      14, 16(1) /* restore r14 */
+        lwz     r14, 16(r1) /* restore r14 */
         bso-    1f
         blr
 
         /* code path when we didn't execute the syscall */
-2:      ld      14, 16(1) /* restore r14 */
-        addi    3, 0, QEMU_ERESTARTSYS
+2:      lwz     r14, 16(r1) /* restore r14 */
+        addi    r3, 0, QEMU_ERESTARTSYS
 
         /* code path setting errno */
 1:      b       safe_syscall_set_errno_tail
         nop     /* per abi, for the linker to modify */
-
-        .cfi_endproc
-
-#if _CALL_ELF == 2
-        .size   safe_syscall_base, .-safe_syscall_base
-#else
-        .size   safe_syscall_base, .-.L.safe_syscall_base
-        .size   .L.safe_syscall_base, .-.L.safe_syscall_base
-#endif



--- common-user/host/ppc64/safe-syscall.inc.S.orig	2022-04-20 03:10:27.000000000 +0800
+++ common-user/host/ppc64/safe-syscall.inc.S	2022-05-31 13:23:21.000000000 +0800
@@ -13,7 +13,6 @@
         .global safe_syscall_base
         .global safe_syscall_start
         .global safe_syscall_end
-        .type   safe_syscall_base, @function
 
         .text
 
@@ -23,19 +22,10 @@
          * second one the system call number (as a 'long'), and all further
          * arguments being syscall arguments (also 'long').
          */
-#if _CALL_ELF == 2
-safe_syscall_base:
-        .cfi_startproc
-        .localentry safe_syscall_base,0
-#else
-        .section ".opd","aw"
+
         .align  3
 safe_syscall_base:
-        .quad   .L.safe_syscall_base,.TOC.@tocbase,0
-        .previous
-.L.safe_syscall_base:
-        .cfi_startproc
-#endif
+
         /* We enter with r3 == &signal_pending
          *               r4 == syscall number
          *               r5 ... r10 == syscall arguments
@@ -46,16 +36,15 @@
          *               and returns the result in r3
          * Shuffle everything around appropriately.
          */
-        std     14, 16(1) /* Preserve r14 in SP+16 */
-        .cfi_offset 14, 16
-        mr      14, 3   /* signal_pending */
-        mr      0, 4    /* syscall number */
-        mr      3, 5    /* syscall arguments */
-        mr      4, 6
-        mr      5, 7
-        mr      6, 8
-        mr      7, 9
-        mr      8, 10
+        std     r14, 16(r1) /* Preserve r14 in SP+16 */
+        mr      r14, r3   /* signal_pending */
+        mr      r0, r4    /* syscall number */
+        mr      r3, r5    /* syscall arguments */
+        mr      r4, r6
+        mr      r5, r7
+        mr      r6, r8
+        mr      r7, r9
+        mr      r8, r10
 
         /* This next sequence of code works in conjunction with the
          * rewind_if_safe_syscall_function(). If a signal is taken
@@ -66,29 +55,20 @@
          */
 safe_syscall_start:
         /* if signal_pending is non-zero, don't do the call */
-        lwz     12, 0(14)
-        cmpwi   0, 12, 0
+        ld      r12, 0(r14)
+        cmpdi   cr0, r12, 0
         bne-    2f
         sc
 safe_syscall_end:
         /* code path when we did execute the syscall */
-        ld      14, 16(1) /* restore r14 */
+        ld      r14, 16(r1) /* restore r14 */
         bso-    1f
         blr
 
         /* code path when we didn't execute the syscall */
-2:      ld      14, 16(1) /* restore r14 */
-        addi    3, 0, QEMU_ERESTARTSYS
+2:      ld      r14, 16(r1) /* restore r14 */
+        addi    r3, 0, QEMU_ERESTARTSYS
 
         /* code path setting errno */
 1:      b       safe_syscall_set_errno_tail
         nop     /* per abi, for the linker to modify */
-
-        .cfi_endproc
-
-#if _CALL_ELF == 2
-        .size   safe_syscall_base, .-safe_syscall_base
-#else
-        .size   safe_syscall_base, .-.L.safe_syscall_base
-        .size   .L.safe_syscall_base, .-.L.safe_syscall_base
-#endif
